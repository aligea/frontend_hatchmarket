{"version":3,"sources":["../pixify/node_modules/browser-pack/_prelude.js","src/Spine.ts","src/core/Animation.ts","src/core/AnimationState.ts","src/core/AnimationStateData.ts","src/core/BlendMode.ts","src/core/Bone.ts","src/core/BoneData.ts","src/core/Event.ts","src/core/EventData.ts","src/core/IkConstraint.ts","src/core/IkConstraintData.ts","src/core/PathConstraint.ts","src/core/PathConstraintData.ts","src/core/Skeleton.ts","src/core/SkeletonBounds.ts","src/core/SkeletonData.ts","src/core/SkeletonJson.ts","src/core/Skin.ts","src/core/Slot.ts","src/core/SlotData.ts","src/core/Texture.ts","src/core/TextureAtlas.ts","src/core/TextureAtlasAttachmentLoader.ts","src/core/TransformConstraint.ts","src/core/TransformConstraintData.ts","src/core/Utils.ts","src/core/attachments/Attachment.ts","src/core/attachments/AttachmentType.ts","src/core/attachments/BoundingBoxAttachment.ts","src/core/attachments/MeshAttachment.ts","src/core/attachments/PathAttachment.ts","src/core/attachments/RegionAttachment.ts","src/core/attachments/index.ts","src/core/index.ts","src/loaders.ts","src/index.ts"],"names":["f","exports","module","define","amd","g","window","global","self","this","PIXI","spine","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","SlotContainerUpdateTransformV3","pt","parent","worldTransform","wt","lt","localTransform","b","c","d","tx","ty","worldAlpha","alpha","_currentBounds","TransformBase","Bone","yDown","tempRgb","SpineSprite","_super","tex","__extends","Sprite","SpineMesh","texture","vertices","uvs","indices","drawMode","mesh","Mesh","Spine","spineData","hackTextureBySlotName","slotName","size","index","skeleton","findSlotIndex","hackTextureBySlotIndex","Skeleton","updateWorldTransform","stateData","AnimationStateData","state","AnimationState","slotContainers","slots","slot","attachment","slotContainer","Container","push","addChild","RegionAttachment","spriteName","region","name","sprite","createSprite","currentSprite","currentSpriteName","MeshAttachment","createMesh","currentMesh","currentMeshName","autoUpdate","tintRgb","Float32Array","Object","defineProperty","prototype","updateTransform","autoUpdateTransform","value","utils","rgb2hex","hex2rgb","update","dt","apply","drawOrder","children","data","r0","g0","b0","attColor","color","ar","visible","sprites","undefined","transform","lt_1","matrix2d","_dirtyVersion","version","isStatic","operMode","position","_dirtyLocal","TransformStatic","_dirtyParentVersion","_versionLocal","bone","matrix","copy","x","y","Matrix","displayObjectUpdateTransform","tint","blendMode","meshName","meshes","computeWorldVertices","VERSION","setSpriteRegion","scale","width","originalWidth","height","originalHeight","scaleX","scaleY","setMeshRegion","updateUVs","dirty","globalAutoUpdate","lastTime","Date","now","timeDelta","defName","tempAttachment","tempRegion","rotation","MathUtils","degRad","anchor","strip","regionUVs","Uint16Array","triangles","DRAW_MODES","TRIANGLES","canvasPadding","slotIndex","TextureRegion","Utils_1","attachments_1","Animation","timelines","duration","time","loop","events","mix","binarySearch","values","target","step","low","high","current","linearSearch","last","CurveTimeline","frameCount","curves","Utils","newFloatArray","BEZIER_SIZE","getFrameCount","setLinear","frameIndex","LINEAR","setStepped","STEPPED","getCurveType","type","BEZIER","setCurve","cx1","cy1","cx2","cy2","tmpx","tmpy","dddfx","dddfy","ddfx","ddfy","dfx","dfy","getCurvePercent","percent","clamp","start","prevX","prevY","RotateTimeline","frames","setFrame","degrees","ROTATION","bones","boneIndex","ENTRIES","amount_1","PREV_ROTATION","frame","prevRotation","frameTime","PREV_TIME","amount","TranslateTimeline","X","Y","PREV_X","PREV_Y","ScaleTimeline","ShearTimeline","shearX","shearY","ColorTimeline","R","G","B","A","PREV_R","PREV_G","PREV_B","PREV_A","add","set","AttachmentTimeline","attachmentNames","Array","attachmentName","setAttachment","getAttachment","EventTimeline","event","firedEvents","Number","MAX_VALUE","DrawOrderTimeline","drawOrders","drawOrderToSetupIndex","arrayCopy","DeformTimeline","frameVertices","slotAttachment","VertexAttachment","applyDeform","vertexCount","verticesArray","attachmentVertices","setArraySize","lastVertices","prevVertices","nextVertices","prev","IkConstraintTimeline","bendDirection","MIX","BEND_DIRECTION","constraint","ikConstraints","ikConstraintIndex","PREV_MIX","Math","floor","PREV_BEND_DIRECTION","TransformConstraintTimeline","rotateMix","translateMix","scaleMix","shearMix","ROTATE","TRANSLATE","SCALE","SHEAR","transformConstraints","transformConstraintIndex","PREV_ROTATE","PREV_TRANSLATE","PREV_SCALE","PREV_SHEAR","rotate","translate","shear","PathConstraintPositionTimeline","VALUE","pathConstraints","pathConstraintIndex","PREV_VALUE","PathConstraintSpacingTimeline","spacing","PathConstraintMixTimeline","tracks","timeScale","delta","next","nextTime","delay","nextDelta","setCurrent","endTime","clearTrack","previous","previousDelta","mixTime","animation","previousTime","mixDuration","ii","nn","event_1","onEvent","count","toInt","onComplete","clearTracks","trackIndex","onEnd","freeAll","entry","expandToIndex","getMix","onStart","setAnimation","animationName","skeletonData","findAnimation","setAnimationWith","TrackEntry","addAnimation","addAnimationWith","hasAnimation","getCurrent","setAnimationByName","deprecatedWarning1","console","warn","addAnimationByName","deprecatedWarning2","hasAnimationByName","deprecatedWarning3","reset","isComplete","animationToMixTime","defaultMix","setMix","fromName","toName","from","to","setMixWith","setMixByName","key","BlendMode","appliedRotation","worldSignX","worldSignY","sorted","setToSetupPose","updateWorldTransformWith","rotationY","la","cosDeg","lb","lc","sinDeg","ld","m","flipX","flipY","signum","pa","pb","pc","pd","inheritRotation","inheritScale","cos","sin","temp","psx","psy","za","zb","zc","zd","getWorldRotationX","atan2","radDeg","getWorldRotationY","getWorldScaleX","sqrt","getWorldScaleY","worldToLocalRotationX","pm","worldToLocalRotationY","rotateWorld","updateLocalTransform","det","pid","dx","dy","ia","id","ib","ic","ra","rb","rc","rd","worldToLocal","world","invDet","localToWorld","local","BoneData","Event","EventData","IkConstraint","level","findBone","apply1","worldX","worldY","apply2","targetX","targetY","pp","rotationIK","child","bendDir","px","py","csx","os1","os2","s2","cx","cy","cwx","cwy","abs","ppm","l1","l2","a1","a2","outer","acos","aa","bb","dd","ta","c1","c2","q","r1","minAngle","minDist","minX","minY","maxAngle","maxDist","maxX","maxY","PI","angle","os","IkConstraintData","PathConstraintData_1","PathConstraint","spaces","positions","lengths","segments","findSlot","PathAttachment","spacingMode","lengthSpacing","SpacingMode","Length","rotateMode","tangents","RotateMode","Tangent","ChainScale","boneCount","spacesCount","length_1","max","computeWorldPositions","positionMode","PositionMode","Percent","skeletonX","skeletonY","boneX","boneY","offsetRotation","tip","Chain","p","length_2","length_3","PI2","path","percentPosition","percentSpacing","out","closed","verticesLength","worldVerticesLength","curveCount","prevCurve","NONE","constantSpeed","pathLength_1","curve","space","BEFORE","computeWorldVerticesWith","addBeforePosition","AFTER","addAfterPosition","length_4","addCurvePosition","pathLength","x1","y1","x2","y2","w","curveLength","segment","length_5","length_6","tt","ttt","uu","uuu","ut","ut3","uut3","utt3","PathConstraintData","Slot_1","Bone_1","IkConstraint_1","TransformConstraint_1","PathConstraint_1","_updateCache","boneData","parent_1","slotData","Slot","ikConstraintsSorted","ikConstraintData","transformConstraintData","TransformConstraint","pathConstraintData","Color","updateCache","ikCount","ik","other","sortBone","constrained","parent_2","sortReset","slotBone","skin","sortPathConstraintAttachment","defaultSkin","skins","sortPathConstraintAttachmentWith","attachments","pathBones","setBonesToSetupPose","setSlotsToSetupPose","getRootBone","boneName","findBoneIndex","setSkinByName","skinName","findSkin","setSkin","newSkin","attachAll","name_1","getAttachmentByName","findIkConstraint","constraintName","ikConstraint","findTransformConstraint","findPathConstraint","getBounds","offset","POSITIVE_INFINITY","NEGATIVE_INFINITY","updateWorldVertices","min","SkeletonBounds","boundingBoxes","polygons","polygonPool","Pool","updateAabb","slotCount","BoundingBoxAttachment","boundingBox","polygon","obtain","aabbCompute","aabbContainsPoint","aabbIntersectsSegment","aabbIntersectsSkeleton","bounds","containsPoint","containsPointPolygon","prevIndex","inside","vertexY","vertexX","intersectsSegment","intersectsSegmentPolygon","width12","height12","det1","x3","y3","x4","y4","det2","width34","height34","det3","getPolygon","indexOf","getWidth","getHeight","SkeletonData","animations","findEvent","eventDataName","findPathConstraintIndex","pathConstraintName","SkeletonData_1","BoneData_1","SlotData_1","Event_1","IkConstraintData_1","TransformConstraintData_1","Skin_1","EventData_1","Animation_1","SkeletonJson","attachmentLoader","linkedMeshes","readSkeletonData","json","root","JSON","parse","skeletonMap","hash","imagesPath","images","boneMap","parentName","getValue","slotMap","SlotData","setFromString","blendModeFromString","constraintMap","j","targetName","TransformConstraintData","offsetX","offsetY","offsetScaleX","offsetScaleY","offsetShearY","positionModeFromString","spacingModeFromString","rotateModeFromString","Fixed","skinMap","Skin","entryName","readAttachment","addAttachment","linkedMesh","setParentMesh","eventName","eventMap","intValue","floatValue","stringValue","animationMap","readAnimation","map","newRegionAttachment","box","newBoundingBoxAttachment","readVertices","newMeshAttachment","parent_3","inheritDeform","LinkedMesh","hullLength","newPathAttachment","newArray","toFloatArray","weights","timelineName","timelineMap","timeline","valueMap","readCurve","timelineScale","paths","deform","deformName","deformMap","weighted","deformLength","verticesValue","drawOrderNode","draworder","drawOrderMap","offsets","unchanged","originalIndex","unchangedIndex","offsetMap","eventData","isNaN","toString","prop","defaultValue","str","BLEND_MODES","MULTIPLY","ADD","SCREEN","NORMAL","toLowerCase","dictionary","oldSkin","skinAttachment","attachmentTime","setAttachmentTime","getAttachmentTime","setFromColor","Texture","image","_image","getImage","filterFromString","text","TextureFilter","Nearest","Linear","MipMap","MipMapNearestNearest","MipMapLinearNearest","MipMapNearestLinear","MipMapLinearLinear","wrapFromString","TextureWrap","MirroredRepeat","ClampToEdge","Repeat","crop","trim","orig","_uvs","x0","y0","spineOffsetY","Texture_1","TextureAtlas","atlasText","textureLoader","callback","pages","regions","addSpineAtlas","addTexture","page","baseTexture","TextureAtlasPage","realWidth","realHeight","minFilter","magFilter","uWrap","vWrap","TextureAtlasRegion","addTextureHash","textures","stripExtension","hasOwnProperty","substr","lastIndexOf","load","_this","reader","TextureAtlasReader","tuple","iterateParser","line","readLine","readTuple","parseInt","direction","readValue","hasLoaded","setFilters","log","resolution","Rectangle","frame2","clone","_updateUvs","findRegion","dispose","lines","split","colon","substring","lastMatch","comma","filter","scaleMode","SCALE_MODES","NEAREST","mipmap","arguments","TextureAtlasAttachmentLoader","atlas","Vector2","tm","tb","tc","td","bs","ts","by","hex","charAt","WHITE","RED","GREEN","BLUE","MAGENTA","ceil","cbrt","pow","radiansToDegrees","degreesToRadians","source","sourceStart","dest","destStart","numElements","array","oldSize","SUPPORTS_TYPED_ARRAYS","DebugUtils","logBones","instantiator","items","pop","free","item","clear","normalize","len","TimeKeeper","maxDelta","framesPerSecond","totalTime","Attachment","worldVertices","deformArray","v","skip","skeletonBones","wx","wy","vx","vy","weight","v_1","sourceAttachment","AttachmentType","Attachment_1","tempColor","premultipliedAlpha","w1","h1","w2","h2","pixiOffsetY","parentMesh","getParentMesh","AttachmentType_1","BoundingBoxAttachment_1","MeshAttachment_1","PathAttachment_1","RegionAttachment_1","__export","AnimationState_1","AnimationStateData_1","BlendMode_1","Skeleton_1","SkeletonBounds_1","SkeletonJson_1","TextureAtlas_1","TextureAtlasAttachmentLoader_1","atlasParser","resource","isJson","metadataAtlas","metadata","spineAtlas","spineJsonParser","metadataAtlasSuffix","spineAtlasSuffix","atlasPath","url","replace","baseUrl","atlasOptions","crossOrigin","xhrType","loaders","Resource","XHR_RESPONSE_TYPE","TEXT","spineMetadata","imageOptions","imageMetadata","adapter","imageLoaderAdapter","xhr","responseText","loader","namePrefix","syncImageLoaderAdapter","BaseTexture","fromImage","Loader","addPixiMiddleware","use","core","Spine_1"],"mappings":"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","file":"pixi-spine.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","import * as spine from \"./core\";\nimport {atlasParser} from \"./loaders\";\nimport {Attachment, VertexAttachment} from \"./core/attachments/Attachment\";\nimport {TextureAtlasRegion} from \"./core/TextureAtlas\";\nvar TransformBase = PIXI.TransformBase;\n\n/* Esoteric Software SPINE wrapper for pixi.js */\nspine.Bone.yDown = true;\n\nlet tempRgb = [0, 0, 0];\n\nexport class SpineSprite extends PIXI.Sprite {\n    region: spine.TextureRegion;\n\n    constructor(tex: PIXI.Texture) {\n        super(tex);\n    }\n}\n\nexport class SpineMesh extends PIXI.mesh.Mesh {\n    region: spine.TextureRegion;\n\n    constructor(texture: PIXI.Texture, vertices?: ArrayLike<number>, uvs?: ArrayLike<number>, indices?: ArrayLike<number>, drawMode?: number) {\n        super(texture, vertices, uvs, indices, drawMode);\n    }\n}\n\n/**\n * A class that enables the you to import and run your spine animations in pixi.\n * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\n *\n * ```js\n * var spineAnimation = new PIXI.Spine(spineData);\n * ```\n *\n * @class\n * @extends Container\n * @memberof PIXI.spine\n * @param spineData {object} The spine data loaded from a spine atlas.\n */\nexport class Spine extends PIXI.Container {\n    static globalAutoUpdate: boolean = true;\n\n    tintRgb: ArrayLike<number>;\n    spineData: spine.SkeletonData;\n    skeleton: spine.Skeleton;\n    stateData: spine.AnimationStateData;\n    state: spine.AnimationState;\n    slotContainers: Array<PIXI.Container>;\n\n    constructor(spineData: spine.SkeletonData) {\n        super();\n\n        if (!spineData) {\n            throw new Error('The spineData param is required.');\n        }\n\n        if ((typeof spineData) === \"string\") {\n            throw new Error('spineData param cant be string. Please use PIXI.spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\n        }\n\n        /**\n         * The spineData object\n         *\n         * @member {object}\n         */\n        this.spineData = spineData;\n\n        /**\n         * A spine Skeleton object\n         *\n         * @member {object}\n         */\n        this.skeleton = new spine.Skeleton(spineData);\n        this.skeleton.updateWorldTransform();\n\n        /**\n         * A spine AnimationStateData object created from the spine data passed in the constructor\n         *\n         * @member {object}\n         */\n        this.stateData = new spine.AnimationStateData(spineData);\n\n        /**\n         * A spine AnimationState object created from the spine AnimationStateData object\n         *\n         * @member {object}\n         */\n        this.state = new spine.AnimationState(this.stateData);\n\n        /**\n         * An array of containers\n         *\n         * @member {Container[]}\n         */\n        this.slotContainers = [];\n\n        for (var i = 0, n = this.skeleton.slots.length; i < n; i++) {\n            var slot = this.skeleton.slots[i];\n            var attachment : any = slot.attachment;\n            var slotContainer = new PIXI.Container();\n            this.slotContainers.push(slotContainer);\n            this.addChild(slotContainer);\n\n            if (attachment instanceof spine.RegionAttachment) {\n                var spriteName = attachment.region.name;\n                var sprite = this.createSprite(slot, attachment, spriteName);\n                slot.currentSprite = sprite;\n                slot.currentSpriteName = spriteName;\n                slotContainer.addChild(sprite);\n            }\n            else if (attachment instanceof spine.MeshAttachment) {\n                var mesh = this.createMesh(slot, attachment);\n                slot.currentMesh = mesh;\n                slot.currentMeshName = attachment.name;\n                slotContainer.addChild(mesh);\n            }\n            else {\n                continue;\n            }\n\n        }\n\n        /**\n         * Should the Spine object update its transforms\n         *\n         * @member {boolean}\n         */\n        this.autoUpdate = true;\n\n        /**\n         * The tint applied to all spine slots. This is a [r,g,b] value. A value of [1,1,1] will remove any tint effect.\n         *\n         * @member {number}\n         * @memberof PIXI.spine.Spine#\n         */\n        this.tintRgb = new Float32Array([1, 1, 1]);\n    }\n\n    /**\n     * If this flag is set to true, the spine animation will be autoupdated every time\n     * the object id drawn. The down side of this approach is that the delta time is\n     * automatically calculated and you could miss out on cool effects like slow motion,\n     * pause, skip ahead and the sorts. Most of these effects can be achieved even with\n     * autoupdate enabled but are harder to achieve.\n     *\n     * @member {boolean}\n     * @memberof PIXI.spine.Spine#\n     * @default true\n     */\n    get autoUpdate(): boolean {\n        return (this.updateTransform === Spine.prototype.autoUpdateTransform);\n    }\n\n    set autoUpdate(value: boolean) {\n        this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform;\n    }\n\n    /**\n     * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     *\n     * @member {number}\n     * @memberof PIXI.spine.Spine#\n     * @default 0xFFFFFF\n     */\n    get tint(): number {\n        return PIXI.utils.rgb2hex(this.tintRgb);\n    }\n\n    set tint(value: number) {\n        this.tintRgb = PIXI.utils.hex2rgb(value, this.tintRgb);\n    }\n\n    /**\n     * Update the spine skeleton and its animations by delta time (dt)\n     *\n     * @param dt {number} Delta time. Time by which the animation should be updated\n     */\n    update(dt: number) {\n        this.state.update(dt);\n        this.state.apply(this.skeleton);\n        this.skeleton.updateWorldTransform();\n\n        let drawOrder = this.skeleton.drawOrder;\n        let slots = this.skeleton.slots;\n\n        for (var i = 0, n = drawOrder.length; i < n; i++) {\n            this.children[i] = this.slotContainers[drawOrder[i].data.index];\n        }\n\n        var r0 = this.tintRgb[0];\n        var g0 = this.tintRgb[1];\n        var b0 = this.tintRgb[2];\n\n        for (i = 0, n = slots.length; i < n; i++) {\n            var slot = slots[i];\n            var attachment = slot.attachment;\n            var slotContainer = this.slotContainers[i];\n\n            if (!attachment) {\n                slotContainer.visible = false;\n                continue;\n            }\n\n            var attColor = (attachment as any).color;\n            if (attachment instanceof spine.RegionAttachment) {\n                let region = (attachment as spine.RegionAttachment).region;\n                if (region) {\n                    let ar = region as TextureAtlasRegion;\n                    if (!slot.currentSpriteName || slot.currentSpriteName !== ar.name) {\n                        var spriteName = ar.name;\n                        if (slot.currentSprite) {\n                            slot.currentSprite.visible = false;\n                        }\n                        slot.sprites = slot.sprites || {};\n                        if (slot.sprites[spriteName] !== undefined) {\n                            slot.sprites[spriteName].visible = true;\n                        }\n                        else {\n                            var sprite = this.createSprite(slot, attachment, spriteName);\n                            slotContainer.addChild(sprite);\n                        }\n                        slot.currentSprite = slot.sprites[spriteName];\n                        slot.currentSpriteName = spriteName;\n                    }\n                }\n\n                if (slotContainer.transform) {\n                    var transform = slotContainer.transform;\n                    let lt : PIXI.Matrix;\n                    if (slotContainer.transform.matrix2d) {\n                        //gameofbombs pixi fork\n                        lt = transform.matrix2d;\n                        transform._dirtyVersion++;\n                        transform.version = transform._dirtyVersion;\n                        transform.isStatic = true;\n                        transform.operMode = 0;\n                    } else {\n                        if (TransformBase) {\n                            //PIXI v4.0\n                            if (transform.position) {\n                                transform = new PIXI.TransformBase();\n                                slotContainer.transform = transform;\n                            }\n                            lt = transform.localTransform;\n                        } else {\n                            //PIXI v4.0rc\n                            if (!transform._dirtyLocal) {\n                                transform = new PIXI.TransformStatic();\n                                slotContainer.transform = transform;\n                            }\n                            lt = transform.localTransform;\n                            transform._dirtyParentVersion = -1;\n                            transform._dirtyLocal = 1;\n                            transform._versionLocal = 1;\n                        }\n                    }\n                    slot.bone.matrix.copy(lt);\n                    lt.tx += slot.bone.skeleton.x;\n                    lt.ty += slot.bone.skeleton.y;\n                } else {\n                    //PIXI v3\n                    var lt = slotContainer.localTransform || new PIXI.Matrix();\n                    slot.bone.matrix.copy(lt);\n                    lt.tx += slot.bone.skeleton.x;\n                    lt.ty += slot.bone.skeleton.y;\n                    slotContainer.localTransform = lt;\n                    slotContainer.displayObjectUpdateTransform = SlotContainerUpdateTransformV3;\n                }\n                tempRgb[0] = r0 * slot.color.r * attColor.r;\n                tempRgb[1] = g0 * slot.color.g * attColor.g;\n                tempRgb[2] = b0 * slot.color.b * attColor.b;\n                slot.currentSprite.tint = PIXI.utils.rgb2hex(tempRgb);\n                slot.currentSprite.blendMode = slot.blendMode;\n            }\n            else if (attachment instanceof spine.MeshAttachment) {\n                if (!slot.currentMeshName || slot.currentMeshName !== attachment.name) {\n                    var meshName = attachment.name;\n                    if (slot.currentMesh) {\n                        slot.currentMesh.visible = false;\n                    }\n\n                    slot.meshes = slot.meshes || {};\n\n                    if (slot.meshes[meshName] !== undefined) {\n                        slot.meshes[meshName].visible = true;\n                    }\n                    else {\n                        var mesh = this.createMesh(slot, attachment);\n                        slotContainer.addChild(mesh);\n                    }\n\n                    slot.currentMesh = slot.meshes[meshName];\n                    slot.currentMeshName = meshName;\n                }\n                (attachment as VertexAttachment).computeWorldVertices(slot, slot.currentMesh.vertices);\n                if (PIXI.VERSION[0] !== '3') {\n                    // PIXI version 4\n                    // slot.currentMesh.dirty++;\n                    //only for PIXI v4\n                    var tintRgb = slot.currentMesh.tintRgb;\n                    tintRgb[0] = r0 * slot.color.r * attColor.r;\n                    tintRgb[1] = g0 * slot.color.g * attColor.g;\n                    tintRgb[2] = b0 * slot.color.b * attColor.b;\n                }\n                slot.currentMesh.blendMode = slot.blendMode;\n            }\n            else {\n                slotContainer.visible = false;\n                continue;\n            }\n            slotContainer.visible = true;\n\n            slotContainer.alpha = slot.color.a;\n        }\n    };\n\n    private setSpriteRegion(attachment: spine.RegionAttachment, sprite: SpineSprite, region: spine.TextureRegion) {\n        sprite.region = region;\n        sprite.texture = region.texture;\n        if (!region.size) {\n            sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;\n            sprite.scale.y = -attachment.scaleY * attachment.height / region.originalHeight;\n        } else {\n            //hacked!\n            sprite.scale.x = region.size.width / region.originalWidth;\n            sprite.scale.y = -region.size.height / region.originalHeight;\n        }\n    }\n\n    private setMeshRegion(attachment: spine.MeshAttachment, mesh: SpineMesh, region: spine.TextureRegion) {\n        mesh.region = region;\n        mesh.texture = region.texture;\n        attachment.updateUVs(region, mesh.uvs);\n        // if (PIXI.VERSION[0] !== '3') {\n            // PIXI version 4\n            // mesh.indexDirty++;\n        // } else {\n            // PIXI version 3\n        mesh.dirty++;\n        // }\n    }\n\n    protected lastTime: number;\n\n    /**\n     * When autoupdate is set to yes this function is used as pixi's updateTransform function\n     *\n     * @private\n     */\n    autoUpdateTransform() {\n        if (Spine.globalAutoUpdate) {\n            this.lastTime = this.lastTime || Date.now();\n            var timeDelta = (Date.now() - this.lastTime) * 0.001;\n            this.lastTime = Date.now();\n            this.update(timeDelta);\n        } else {\n            this.lastTime = 0;\n        }\n\n        PIXI.Container.prototype.updateTransform.call(this);\n    };\n\n    /**\n     * Create a new sprite to be used with spine.RegionAttachment\n     *\n     * @param slot {spine.Slot} The slot to which the attachment is parented\n     * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n     * @private\n     */\n    createSprite(slot: spine.Slot, attachment: spine.RegionAttachment, defName: string) {\n        let region = attachment.region;\n        if (slot.tempAttachment === attachment) {\n            region = slot.tempRegion;\n            slot.tempAttachment = null;\n            slot.tempRegion = null;\n        }\n        var texture = region.texture;\n        var sprite = new SpineSprite(texture);\n        sprite.rotation = attachment.rotation * spine.MathUtils.degRad;\n        sprite.anchor.x = 0.5;\n        sprite.anchor.y = 0.5;\n        sprite.position.x = attachment.x;\n        sprite.position.y = attachment.y;\n        sprite.alpha = attachment.color.a;\n\n        sprite.region = attachment.region;\n        this.setSpriteRegion(attachment, sprite, attachment.region);\n\n        slot.sprites = slot.sprites || {};\n        slot.sprites[defName] = sprite;\n        return sprite;\n    };\n\n    /**\n     * Creates a Strip from the spine data\n     * @param slot {spine.Slot} The slot to which the attachment is parented\n     * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n     * @private\n     */\n    createMesh(slot: spine.Slot, attachment: spine.MeshAttachment) {\n        let region = attachment.region;\n        if (slot.tempAttachment === attachment) {\n            region = slot.tempRegion;\n            slot.tempAttachment = null;\n            slot.tempRegion = null;\n        }\n        let strip = new SpineMesh(\n            region.texture,\n            new Float32Array(attachment.regionUVs.length),\n            new Float32Array(attachment.regionUVs.length),\n            new Uint16Array(attachment.triangles),\n            PIXI.mesh.Mesh.DRAW_MODES.TRIANGLES);\n\n        strip.canvasPadding = 1.5;\n\n        strip.alpha = attachment.color.a;\n\n        strip.region = attachment.region;\n        this.setMeshRegion(attachment, strip, region);\n\n        slot.meshes = slot.meshes || {};\n        slot.meshes[attachment.name] = strip;\n        return strip;\n    };\n\n    /**\n     * Changes texture in attachment in specific slot.\n     *\n     * PIXI runtime feature, it was made to satisfy our users.\n     *\n     * @param slotIndex {number}\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n     * @returns {boolean} Success flag\n     */\n    hackTextureBySlotIndex(slotIndex: number, texture: PIXI.Texture = null, size: PIXI.Rectangle = null) {\n        var slot = this.skeleton.slots[slotIndex];\n        if (!slot) {\n            return false;\n        }\n        var attachment: any = slot.attachment;\n        var region: spine.TextureRegion = attachment.region;\n        if (texture) {\n            region = new spine.TextureRegion();\n            region.texture = texture;\n            region.size = size;\n        }\n        if (slot.currentSprite && slot.currentSprite.region != region) {\n            this.setSpriteRegion(attachment, slot.currentSprite, region);\n            slot.currentSprite.region = region;\n        } else\n        if (slot.currentMesh && slot.currentMesh.region != region) {\n            this.setMeshRegion(attachment, slot.currentMesh, region);\n        } else {\n            slot.tempRegion = region;\n            slot.tempAttachment = attachment;\n        }\n        return true;\n    }\n\n    /**\n     * Changes texture in attachment in specific slot.\n     *\n     * PIXI runtime feature, it was made to satisfy our users.\n     *\n     * @param slotName {string}\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n     * @returns {boolean} Success flag\n     */\n    hackTextureBySlotName = function (slotName: String, texture: PIXI.Texture = null, size: PIXI.Rectangle = null) {\n        var index = this.skeleton.findSlotIndex(slotName);\n        if (index == -1) {\n            return false;\n        }\n        return this.hackTextureBySlotIndex(index, texture, size);\n    }\n}\n\nfunction SlotContainerUpdateTransformV3() {\n    var pt = this.parent.worldTransform;\n    var wt = this.worldTransform;\n    var lt = this.localTransform;\n    wt.a = lt.a * pt.a + lt.b * pt.c;\n    wt.b = lt.a * pt.b + lt.b * pt.d;\n    wt.c = lt.c * pt.a + lt.d * pt.c;\n    wt.d = lt.c * pt.b + lt.d * pt.d;\n    wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\n    wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    this._currentBounds = null;\n}\n","import {Event} from \"./Event\";\r\nimport {Skeleton} from \"./Skeleton\";\r\nimport {PathConstraint} from \"./PathConstraint\";\r\nimport {Utils, MathUtils, Color} from \"./Utils\";\r\nimport {TransformConstraint} from \"./TransformConstraint\";\r\nimport {IkConstraint} from \"./IkConstraint\";\r\nimport {VertexAttachment, Attachment} from \"./attachments\";\r\nimport {Slot} from \"./Slot\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class Animation {\r\n    name: string;\r\n    timelines: Array<Timeline>;\r\n    duration: number;\r\n\r\n    constructor (name: string, timelines: Array<Timeline>, duration: number) {\r\n        if (name == null) throw new Error(\"name cannot be null.\");\r\n        if (timelines == null) throw new Error(\"timelines cannot be null.\");\r\n        this.name = name;\r\n        this.timelines = timelines;\r\n        this.duration = duration;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>) {\r\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n\r\n        if (loop && this.duration != 0) {\r\n            time %= this.duration;\r\n            if (lastTime > 0) lastTime %= this.duration;\r\n        }\r\n\r\n        let timelines = this.timelines;\r\n        for (let i = 0, n = timelines.length; i < n; i++)\r\n            timelines[i].apply(skeleton, lastTime, time, events, 1);\r\n    }\r\n\r\n    mix (skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>, alpha: number) {\r\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n\r\n        if (loop && this.duration != 0) {\r\n            time %= this.duration;\r\n            if (lastTime > 0) lastTime %= this.duration;\r\n        }\r\n\r\n        let timelines = this.timelines;\r\n        for (let i = 0, n = timelines.length; i < n; i++)\r\n            timelines[i].apply(skeleton, lastTime, time, events, alpha);\r\n    }\r\n\r\n    static binarySearch (values: ArrayLike<number>, target: number, step: number = 1) {\r\n        let low = 0;\r\n        let high = values.length / step - 2;\r\n        if (high == 0) return step;\r\n        let current = high >>> 1;\r\n        while (true) {\r\n            if (values[(current + 1) * step] <= target)\r\n                low = current + 1;\r\n            else\r\n                high = current;\r\n            if (low == high) return (low + 1) * step;\r\n            current = (low + high) >>> 1;\r\n        }\r\n    }\r\n\r\n    static linearSearch (values: ArrayLike<number>, target: number, step: number) {\r\n        for (let i = 0, last = values.length - step; i <= last; i += step)\r\n            if (values[i] > target) return i;\r\n        return -1;\r\n    }\r\n}\r\n\r\nexport interface Timeline {\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number): void;\r\n}\r\n\r\nexport abstract class CurveTimeline implements Timeline {\r\n    static LINEAR = 0; static STEPPED = 1; static BEZIER = 2;\r\n    static BEZIER_SIZE = 10 * 2 - 1;\r\n\r\n    private curves: ArrayLike<number>; // type, x, y, ...\r\n\r\n    constructor (frameCount: number) {\r\n        if (frameCount <= 0) throw new Error(\"frameCount must be > 0: \" + frameCount);\r\n        this.curves = Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\r\n    }\r\n\r\n    getFrameCount () {\r\n        return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\r\n    }\r\n\r\n    setLinear (frameIndex: number) {\r\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\r\n    }\r\n\r\n    setStepped (frameIndex: number) {\r\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\r\n    }\r\n\r\n    getCurveType (frameIndex: number): number {\r\n        let index = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n        if (index == this.curves.length) return CurveTimeline.LINEAR;\r\n        let type = this.curves[index];\r\n        if (type == CurveTimeline.LINEAR) return CurveTimeline.LINEAR;\r\n        if (type == CurveTimeline.STEPPED) return CurveTimeline.STEPPED;\r\n        return CurveTimeline.BEZIER;\r\n    }\r\n\r\n    /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.\r\n     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of\r\n     * the difference between the keyframe's values. */\r\n    setCurve (frameIndex: number, cx1: number, cy1: number, cx2: number, cy2: number) {\r\n        let tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;\r\n        let dddfx = ((cx1 - cx2) * 3 + 1) * 0.006, dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\r\n        let ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;\r\n        let dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667, dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\r\n\r\n        let i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n        let curves = this.curves;\r\n        curves[i++] = CurveTimeline.BEZIER;\r\n\r\n        let x = dfx, y = dfy;\r\n        for (let n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n            curves[i] = x;\r\n            curves[i + 1] = y;\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            ddfx += dddfx;\r\n            ddfy += dddfy;\r\n            x += dfx;\r\n            y += dfy;\r\n        }\r\n    }\r\n\r\n    getCurvePercent (frameIndex: number, percent: number) {\r\n        percent = MathUtils.clamp(percent, 0, 1);\r\n        let curves = this.curves;\r\n        let i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n        let type = curves[i];\r\n        if (type == CurveTimeline.LINEAR) return percent;\r\n        if (type == CurveTimeline.STEPPED) return 0;\r\n        i++;\r\n        let x = 0;\r\n        for (let start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n            x = curves[i];\r\n            if (x >= percent) {\r\n                let prevX: number, prevY: number;\r\n                if (i == start) {\r\n                    prevX = 0;\r\n                    prevY = 0;\r\n                } else {\r\n                    prevX = curves[i - 2];\r\n                    prevY = curves[i - 1];\r\n                }\r\n                return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\r\n            }\r\n        }\r\n        let y = curves[i - 1];\r\n        return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.\r\n    }\r\n\r\n    abstract apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number): void;\r\n}\r\n\r\nexport class RotateTimeline extends CurveTimeline {\r\n    static ENTRIES = 2;\r\n    static PREV_TIME = -2; static PREV_ROTATION = -1;\r\n    static ROTATION = 1;\r\n\r\n    boneIndex: number;\r\n    frames: ArrayLike<number>; // time, degrees, ...\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount << 1);\r\n    }\r\n\r\n    /** Sets the time and angle of the specified keyframe. */\r\n    setFrame (frameIndex: number, time: number, degrees: number) {\r\n        frameIndex <<= 1;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number) {\r\n        let frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        let bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - RotateTimeline.ENTRIES]) { // Time is after last frame.\r\n            let amount = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] - bone.rotation;\r\n            while (amount > 180)\r\n                amount -= 360;\r\n            while (amount < -180)\r\n                amount += 360;\r\n            bone.rotation += amount * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        let frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\r\n        let prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\r\n        let frameTime = frames[frame];\r\n        let percent = this.getCurvePercent((frame >> 1) - 1,\r\n            1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\r\n\r\n        let amount = frames[frame + RotateTimeline.ROTATION] - prevRotation;\r\n        while (amount > 180)\r\n            amount -= 360;\r\n        while (amount < -180)\r\n            amount += 360;\r\n        amount = bone.data.rotation + (prevRotation + amount * percent) - bone.rotation;\r\n        while (amount > 180)\r\n            amount -= 360;\r\n        while (amount < -180)\r\n            amount += 360;\r\n        bone.rotation += amount * alpha;\r\n    }\r\n}\r\n\r\nexport class TranslateTimeline extends CurveTimeline {\r\n    static ENTRIES = 3;\r\n    static PREV_TIME = -3; static PREV_X = -2; static PREV_Y = -1;\r\n    static X = 1; static Y = 2;\r\n\r\n    boneIndex: number;\r\n    frames: ArrayLike<number>; // time, x, y, ...\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\r\n    }\r\n\r\n    /** Sets the time and value of the specified keyframe. */\r\n    setFrame (frameIndex: number, time: number, x: number, y: number) {\r\n        frameIndex *= TranslateTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + TranslateTimeline.X] = x;\r\n        this.frames[frameIndex + TranslateTimeline.Y] = y;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number) {\r\n        let frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        let bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) { // Time is after last frame.\r\n            bone.x += (bone.data.x + frames[frames.length + TranslateTimeline.PREV_X] - bone.x) * alpha;\r\n            bone.y += (bone.data.y + frames[frames.length + TranslateTimeline.PREV_Y] - bone.y) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        let frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\r\n        let prevX = frames[frame + TranslateTimeline.PREV_X];\r\n        let prevY = frames[frame + TranslateTimeline.PREV_Y];\r\n        let frameTime = frames[frame];\r\n        let percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1,\r\n            1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\r\n\r\n        bone.x += (bone.data.x + prevX + (frames[frame + TranslateTimeline.X] - prevX) * percent - bone.x) * alpha;\r\n        bone.y += (bone.data.y + prevY + (frames[frame + TranslateTimeline.Y] - prevY) * percent - bone.y) * alpha;\r\n    }\r\n}\r\n\r\nexport class ScaleTimeline extends TranslateTimeline {\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number) {\r\n        let frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) { // Time is after last frame.\r\n            bone.scaleX += (bone.data.scaleX * frames[frames.length + ScaleTimeline.PREV_X] - bone.scaleX) * alpha;\r\n            bone.scaleY += (bone.data.scaleY * frames[frames.length + ScaleTimeline.PREV_Y] - bone.scaleY) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        let frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\r\n        let prevX = frames[frame + ScaleTimeline.PREV_X];\r\n        let prevY = frames[frame + ScaleTimeline.PREV_Y];\r\n        let frameTime = frames[frame];\r\n        let percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1,\r\n            1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\r\n\r\n        bone.scaleX += (bone.data.scaleX * (prevX + (frames[frame + ScaleTimeline.X] - prevX) * percent) - bone.scaleX) * alpha;\r\n        bone.scaleY += (bone.data.scaleY * (prevY + (frames[frame + ScaleTimeline.Y] - prevY) * percent) - bone.scaleY) * alpha;\r\n    }\r\n}\r\n\r\nexport class ShearTimeline extends TranslateTimeline {\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number) {\r\n        let frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        let bone = skeleton.bones[this.boneIndex];\r\n        if (time >= frames[frames.length - ShearTimeline.ENTRIES]) { // Time is after last frame.\r\n            bone.shearX += (bone.data.shearX + frames[frames.length + ShearTimeline.PREV_X] - bone.shearX) * alpha;\r\n            bone.shearY += (bone.data.shearY + frames[frames.length + ShearTimeline.PREV_Y] - bone.shearY) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        let frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\r\n        let prevX = frames[frame + ShearTimeline.PREV_X];\r\n        let prevY = frames[frame + ShearTimeline.PREV_Y];\r\n        let frameTime = frames[frame];\r\n        let percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1,\r\n            1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\r\n\r\n        bone.shearX += (bone.data.shearX + (prevX + (frames[frame + ShearTimeline.X] - prevX) * percent) - bone.shearX) * alpha;\r\n        bone.shearY += (bone.data.shearY + (prevY + (frames[frame + ShearTimeline.Y] - prevY) * percent) - bone.shearY) * alpha;\r\n    }\r\n}\r\n\r\nexport class ColorTimeline extends CurveTimeline {\r\n    static ENTRIES = 5;\r\n    static PREV_TIME = -5; static PREV_R = -4; static PREV_G = -3; static PREV_B = -2; static PREV_A = -1;\r\n    static R = 1; static G = 2; static B = 3; static A = 4;\r\n\r\n    slotIndex: number;\r\n    frames: ArrayLike<number>; // time, r, g, b, a, ...\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\r\n    }\r\n\r\n    /** Sets the time and value of the specified keyframe. */\r\n    setFrame (frameIndex: number, time: number, r: number, g: number, b: number, a: number) {\r\n        frameIndex *= ColorTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + ColorTimeline.R] = r;\r\n        this.frames[frameIndex + ColorTimeline.G] = g;\r\n        this.frames[frameIndex + ColorTimeline.B] = b;\r\n        this.frames[frameIndex + ColorTimeline.A] = a;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number) {\r\n        let frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        let r = 0, g = 0, b = 0, a = 0;\r\n        if (time >= frames[frames.length - ColorTimeline.ENTRIES]) { // Time is after last frame.\r\n            let i = frames.length;\r\n            r = frames[i + ColorTimeline.PREV_R];\r\n            g = frames[i + ColorTimeline.PREV_G];\r\n            b = frames[i + ColorTimeline.PREV_B];\r\n            a = frames[i + ColorTimeline.PREV_A];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            let frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\r\n            r = frames[frame + ColorTimeline.PREV_R];\r\n            g = frames[frame + ColorTimeline.PREV_G];\r\n            b = frames[frame + ColorTimeline.PREV_B];\r\n            a = frames[frame + ColorTimeline.PREV_A];\r\n            let frameTime = frames[frame];\r\n            let percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1,\r\n                1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\r\n\r\n            r += (frames[frame + ColorTimeline.R] - r) * percent;\r\n            g += (frames[frame + ColorTimeline.G] - g) * percent;\r\n            b += (frames[frame + ColorTimeline.B] - b) * percent;\r\n            a += (frames[frame + ColorTimeline.A] - a) * percent;\r\n        }\r\n        let color: Color = skeleton.slots[this.slotIndex].color;\r\n        if (alpha < 1)\r\n            color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\r\n        else\r\n            color.set(r, g, b, a);\r\n    }\r\n}\r\n\r\nexport class AttachmentTimeline implements Timeline {\r\n    slotIndex: number;\r\n    frames: ArrayLike<number> // time, ...\r\n    attachmentNames: Array<string>;\r\n\r\n    constructor (frameCount: number) {\r\n        this.frames = Utils.newFloatArray(frameCount);\r\n        this.attachmentNames = new Array<string>(frameCount);\r\n    }\r\n\r\n    getFrameCount () {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time and value of the specified keyframe. */\r\n    setFrame (frameIndex: number, time: number, attachmentName: string) {\r\n        this.frames[frameIndex] = time;\r\n        this.attachmentNames[frameIndex] = attachmentName;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number) {\r\n        let frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        let frameIndex = 0;\r\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\r\n            frameIndex = frames.length - 1;\r\n        else\r\n            frameIndex = Animation.binarySearch(frames, time, 1) - 1;\r\n\r\n        let attachmentName = this.attachmentNames[frameIndex];\r\n        skeleton.slots[this.slotIndex]\r\n            .setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\r\n    }\r\n}\r\n\r\nexport class EventTimeline implements Timeline {\r\n    frames: ArrayLike<number>; // time, ...\r\n    events: Array<Event>;\r\n\r\n    constructor (frameCount: number) {\r\n        this.frames = Utils.newFloatArray(frameCount);\r\n        this.events = new Array<Event>(frameCount);\r\n    }\r\n\r\n    getFrameCount () {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time of the specified keyframe. */\r\n    setFrame (frameIndex: number, event: Event) {\r\n        this.frames[frameIndex] = event.time;\r\n        this.events[frameIndex] = event;\r\n    }\r\n\r\n    /** Fires events for frames > lastTime and <= time. */\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\r\n        if (firedEvents == null) return;\r\n        let frames = this.frames;\r\n        let frameCount = this.frames.length;\r\n\r\n        if (lastTime > time) { // Fire events after last time for looped animations.\r\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha);\r\n            lastTime = -1;\r\n        } else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\r\n            return;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        let frame = 0;\r\n        if (lastTime < frames[0])\r\n            frame = 0;\r\n        else {\r\n            frame = Animation.binarySearch(frames, lastTime);\r\n            let frameTime = frames[frame];\r\n            while (frame > 0) { // Fire multiple events with the same frame.\r\n                if (frames[frame - 1] != frameTime) break;\r\n                frame--;\r\n            }\r\n        }\r\n        for (; frame < frameCount && time >= frames[frame]; frame++)\r\n            firedEvents.push(this.events[frame]);\r\n    }\r\n}\r\n\r\nexport class DrawOrderTimeline implements Timeline {\r\n    frames: ArrayLike<number>; // time, ...\r\n    drawOrders: Array<Array<number>>;\r\n\r\n    constructor (frameCount: number) {\r\n        this.frames = Utils.newFloatArray(frameCount);\r\n        this.drawOrders = new Array<Array<number>>(frameCount);\r\n    }\r\n\r\n    getFrameCount () {\r\n        return this.frames.length;\r\n    }\r\n\r\n    /** Sets the time of the specified keyframe.\r\n     * @param drawOrder May be null to use bind pose draw order. */\r\n    setFrame (frameIndex: number, time: number, drawOrder: Array<number>) {\r\n        this.frames[frameIndex] = time;\r\n        this.drawOrders[frameIndex] = drawOrder;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\r\n        let frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        let frame = 0;\r\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\r\n            frame = frames.length - 1;\r\n        else\r\n            frame = Animation.binarySearch(frames, time) - 1;\r\n\r\n        let drawOrder: Array<Slot> = skeleton.drawOrder;\r\n        let slots: Array<Slot> = skeleton.slots;\r\n        let drawOrderToSetupIndex = this.drawOrders[frame];\r\n        if (drawOrderToSetupIndex == null)\r\n            Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\r\n        else {\r\n            for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\r\n                drawOrder[i] = slots[drawOrderToSetupIndex[i]];\r\n        }\r\n    }\r\n}\r\n\r\nexport class DeformTimeline extends CurveTimeline {\r\n    frames: ArrayLike<number>; // time, ...\r\n    frameVertices: Array<ArrayLike<number>>;\r\n    slotIndex: number;\r\n    attachment: VertexAttachment;\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount);\r\n        this.frameVertices = new Array<ArrayLike<number>>(frameCount);\r\n    }\r\n\r\n    /** Sets the time of the specified keyframe. */\r\n    setFrame (frameIndex: number, time: number, vertices: ArrayLike<number>) {\r\n        this.frames[frameIndex] = time;\r\n        this.frameVertices[frameIndex] = vertices;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\r\n        let slot: Slot = skeleton.slots[this.slotIndex];\r\n        let slotAttachment: Attachment = slot.getAttachment();\r\n        if (!(slotAttachment instanceof VertexAttachment) || !(<VertexAttachment>slotAttachment).applyDeform(this.attachment)) return;\r\n\r\n        let frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        let frameVertices = this.frameVertices;\r\n        let vertexCount = frameVertices[0].length;\r\n\r\n        let verticesArray: Array<number> = slot.attachmentVertices;\r\n        if (verticesArray.length != vertexCount) alpha = 1; // Don't mix from uninitialized slot vertices.\r\n        let vertices: Array<number> = Utils.setArraySize(verticesArray, vertexCount);\r\n\r\n        if (time >= frames[frames.length - 1]) { // Time is after last frame.\r\n            let lastVertices = frameVertices[frames.length - 1];\r\n            if (alpha < 1) {\r\n                for (let i = 0; i < vertexCount; i++)\r\n                    vertices[i] += (lastVertices[i] - vertices[i]) * alpha;\r\n            } else\r\n                Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        let frame = Animation.binarySearch(frames, time);\r\n        let prevVertices = frameVertices[frame - 1];\r\n        let nextVertices = frameVertices[frame];\r\n        let frameTime = frames[frame];\r\n        let percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\r\n\r\n        if (alpha < 1) {\r\n            for (let i = 0; i < vertexCount; i++) {\r\n                let prev = prevVertices[i];\r\n                vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;\r\n            }\r\n        } else {\r\n            for (let i = 0; i < vertexCount; i++) {\r\n                let prev = prevVertices[i];\r\n                vertices[i] = prev + (nextVertices[i] - prev) * percent;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport class IkConstraintTimeline extends CurveTimeline {\r\n    static ENTRIES = 3;\r\n    static PREV_TIME = -3; static PREV_MIX = -2; static PREV_BEND_DIRECTION = -1;\r\n    static MIX = 1; static BEND_DIRECTION = 2;\r\n\r\n    ikConstraintIndex: number;\r\n    frames: ArrayLike<number>; // time, mix, bendDirection, ...\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\r\n    }\r\n\r\n    /** Sets the time, mix and bend direction of the specified keyframe. */\r\n    setFrame (frameIndex: number, time: number, mix: number, bendDirection: number) {\r\n        frameIndex *= IkConstraintTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\r\n        this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\r\n        let frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        let constraint: IkConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\r\n\r\n        if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) { // Time is after last frame.\r\n            constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\r\n            constraint.bendDirection = Math.floor(frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION]);\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        let frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\r\n        let mix = frames[frame + IkConstraintTimeline.PREV_MIX];\r\n        let frameTime = frames[frame];\r\n        let percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1,\r\n            1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\r\n\r\n        constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\r\n        constraint.bendDirection = Math.floor(frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION]);\r\n    }\r\n}\r\n\r\nexport class TransformConstraintTimeline extends CurveTimeline {\r\n    static ENTRIES = 5;\r\n    static PREV_TIME = -5; static PREV_ROTATE = -4; static PREV_TRANSLATE = -3; static PREV_SCALE = -2; static PREV_SHEAR = -1;\r\n    static ROTATE = 1; static TRANSLATE = 2; static SCALE = 3; static SHEAR = 4;\r\n\r\n    transformConstraintIndex: number;\r\n    frames: ArrayLike<number>; // time, rotate mix, translate mix, scale mix, shear mix, ...\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\r\n    }\r\n\r\n    /** Sets the time and mixes of the specified keyframe. */\r\n    setFrame (frameIndex: number, time: number, rotateMix: number, translateMix: number, scaleMix: number, shearMix: number) {\r\n        frameIndex *= TransformConstraintTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\r\n        this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\r\n        this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\r\n        this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\r\n        let frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        let constraint: TransformConstraint = skeleton.transformConstraints[this.transformConstraintIndex];\r\n\r\n        if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) { // Time is after last frame.\r\n            let i = frames.length;\r\n            constraint.rotateMix += (frames[i + TransformConstraintTimeline.PREV_ROTATE] - constraint.rotateMix) * alpha;\r\n            constraint.translateMix += (frames[i + TransformConstraintTimeline.PREV_TRANSLATE] - constraint.translateMix) * alpha;\r\n            constraint.scaleMix += (frames[i + TransformConstraintTimeline.PREV_SCALE] - constraint.scaleMix) * alpha;\r\n            constraint.shearMix += (frames[i + TransformConstraintTimeline.PREV_SHEAR] - constraint.shearMix) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        let frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\r\n        let frameTime = frames[frame];\r\n        let percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1,\r\n            1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));\r\n\r\n        let rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\r\n        let translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\r\n        let scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\r\n        let shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\r\n        constraint.rotateMix += (rotate + (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent - constraint.rotateMix) * alpha;\r\n        constraint.translateMix += (translate + (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent - constraint.translateMix)\r\n            * alpha;\r\n        constraint.scaleMix += (scale + (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent - constraint.scaleMix) * alpha;\r\n        constraint.shearMix += (shear + (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent - constraint.shearMix) * alpha;\r\n    }\r\n}\r\n\r\nexport class PathConstraintPositionTimeline extends CurveTimeline {\r\n    static ENTRIES = 2;\r\n    static PREV_TIME = -2; static PREV_VALUE = -1;\r\n    static VALUE = 1;\r\n\r\n    pathConstraintIndex: number;\r\n\r\n    frames: ArrayLike<number>; // time, position, ...\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\r\n    }\r\n\r\n    /** Sets the time and value of the specified keyframe. */\r\n    setFrame (frameIndex: number, time: number, value: number) {\r\n        frameIndex *= PathConstraintPositionTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\r\n        let frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\r\n        if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES]) { // Time is after last frame.\r\n            let i = frames.length;\r\n            constraint.position += (frames[i + PathConstraintPositionTimeline.PREV_VALUE] - constraint.position) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        let frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\r\n        let position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\r\n        let frameTime = frames[frame];\r\n        let percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1,\r\n            1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));\r\n\r\n        constraint.position += (position + (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent - constraint.position) * alpha;\r\n    }\r\n}\r\n\r\nexport class PathConstraintSpacingTimeline extends PathConstraintPositionTimeline {\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\r\n        let frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\r\n        if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES]) { // Time is after last frame.\r\n            let i = frames.length;\r\n            constraint.spacing += (frames[i + PathConstraintSpacingTimeline.PREV_VALUE] - constraint.spacing) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        let frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\r\n        let spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\r\n        let frameTime = frames[frame];\r\n        let percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1,\r\n            1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));\r\n\r\n        constraint.spacing += (spacing + (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent - constraint.spacing) * alpha;\r\n    }\r\n}\r\n\r\nexport class PathConstraintMixTimeline extends CurveTimeline {\r\n    static ENTRIES = 3;\r\n    static PREV_TIME = -3; static PREV_ROTATE = -2; static PREV_TRANSLATE = -1;\r\n    static ROTATE = 1; static TRANSLATE = 2;\r\n\r\n    pathConstraintIndex: number;\r\n\r\n    frames: ArrayLike<number>; // time, rotate mix, translate mix, ...\r\n\r\n    constructor (frameCount: number) {\r\n        super(frameCount);\r\n        this.frames = Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\r\n    }\r\n\r\n    /** Sets the time and mixes of the specified keyframe. */\r\n    setFrame (frameIndex: number, time: number, rotateMix: number, translateMix: number) {\r\n        frameIndex *= PathConstraintMixTimeline.ENTRIES;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\r\n        this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\r\n    }\r\n\r\n    apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number) {\r\n        let frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\r\n        if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) { // Time is after last frame.\r\n            let i = frames.length;\r\n            constraint.rotateMix += (frames[i + PathConstraintMixTimeline.PREV_ROTATE] - constraint.rotateMix) * alpha;\r\n            constraint.translateMix += (frames[i + PathConstraintMixTimeline.PREV_TRANSLATE] - constraint.translateMix) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        let frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\r\n        let rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\r\n        let translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\r\n        let frameTime = frames[frame];\r\n        let percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1,\r\n            1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));\r\n\r\n        constraint.rotateMix += (rotate + (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent - constraint.rotateMix) * alpha;\r\n        constraint.translateMix += (translate + (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent - constraint.translateMix)\r\n            * alpha;\r\n    }\r\n}\r\n","import {Skeleton} from \"./Skeleton\";\r\nimport {MathUtils, Utils} from \"./Utils\";\r\nimport {Animation} from \"./Animation\";\r\nimport {AnimationStateData} from \"./AnimationStateData\";\r\nimport {Event} from \"./Event\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class AnimationState {\r\n    data: AnimationStateData;\r\n    tracks = new Array<TrackEntry>();\r\n    events = new Array<Event>();\r\n    timeScale = 1;\r\n\r\n    constructor (data: AnimationStateData = null) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        this.data = data;\r\n    }\r\n\r\n    update (delta: number) {\r\n        delta *= this.timeScale;\r\n        for (let i = 0; i < this.tracks.length; i++) {\r\n            let current = this.tracks[i];\r\n            if (current == null) continue;\r\n\r\n            let next = current.next;\r\n            if (next != null) {\r\n                let nextTime = current.lastTime - next.delay;\r\n                if (nextTime >= 0) {\r\n                    let nextDelta = delta * next.timeScale;\r\n                    next.time = nextTime + nextDelta; // For start event to see correct time.\r\n                    current.time += delta * current.timeScale; // For end event to see correct time.\r\n                    this.setCurrent(i, next);\r\n                    next.time -= nextDelta; // Prevent increasing time twice, below.\r\n                    current = next;\r\n                }\r\n            } else if (!current.loop && current.lastTime >= current.endTime) {\r\n                // End non-looping animation when it reaches its end time and there is no next entry.\r\n                this.clearTrack(i);\r\n                continue;\r\n            }\r\n\r\n            current.time += delta * current.timeScale;\r\n            if (current.previous != null) {\r\n                let previousDelta = delta * current.previous.timeScale;\r\n                current.previous.time += previousDelta;\r\n                current.mixTime += previousDelta;\r\n            }\r\n        }\r\n    }\r\n\r\n    apply (skeleton: Skeleton) {\r\n        let events = this.events;\r\n\r\n        for (let i = 0; i < this.tracks.length; i++) {\r\n            let current = this.tracks[i];\r\n            if (current == null) continue;\r\n\r\n            events.length = 0;\r\n\r\n            let time = current.time;\r\n            let lastTime = current.lastTime;\r\n            let endTime = current.endTime;\r\n            let loop = current.loop;\r\n            if (!loop && time > endTime) time = endTime;\r\n\r\n            let previous = current.previous;\r\n            if (previous == null)\r\n                current.animation.mix(skeleton, lastTime, time, loop, events, current.mix);\r\n            else {\r\n                let previousTime = previous.time;\r\n                if (!previous.loop && previousTime > previous.endTime) previousTime = previous.endTime;\r\n                previous.animation.apply(skeleton, previousTime, previousTime, previous.loop, null);\r\n\r\n                let alpha = current.mixTime / current.mixDuration * current.mix;\r\n                if (alpha >= 1) {\r\n                    alpha = 1;\r\n                    current.previous = null;\r\n                }\r\n                current.animation.mix(skeleton, lastTime, time, loop, events, alpha);\r\n            }\r\n\r\n            for (let ii = 0, nn = events.length; ii < nn; ii++) {\r\n                let event = events[ii];\r\n                if (current.onEvent) current.onEvent(i, event);\r\n                if (this.onEvent) this.onEvent(i, event);\r\n            }\r\n\r\n            // Check if completed the animation or a loop iteration.\r\n            if (loop ? (lastTime % endTime > time % endTime) : (lastTime < endTime && time >= endTime)) {\r\n                let count = MathUtils.toInt(time / endTime);\r\n                if (current.onComplete) current.onComplete(i, count);\r\n                if (this.onComplete) this.onComplete(i, count);\r\n            }\r\n\r\n            current.lastTime = current.time;\r\n        }\r\n    }\r\n\r\n    clearTracks () {\r\n        for (let i = 0, n = this.tracks.length; i < n; i++)\r\n            this.clearTrack(i);\r\n        this.tracks.length = 0;\r\n    }\r\n\r\n    clearTrack (trackIndex: number) {\r\n        if (trackIndex >= this.tracks.length) return;\r\n        let current = this.tracks[trackIndex];\r\n        if (current == null) return;\r\n\r\n        if (current.onEnd) current.onEnd(trackIndex);\r\n        if (this.onEnd) this.onEnd(trackIndex);\r\n\r\n        this.tracks[trackIndex] = null;\r\n\r\n        this.freeAll(current);\r\n    }\r\n\r\n    freeAll (entry: TrackEntry) {\r\n        while (entry != null) {\r\n            let next = entry.next;\r\n            entry = next;\r\n        }\r\n    }\r\n\r\n    expandToIndex (index: number) {\r\n        if (index < this.tracks.length) return this.tracks[index];\r\n        Utils.setArraySize(this.tracks, index - this.tracks.length + 1, null);\r\n        this.tracks.length = index + 1;\r\n        return null;\r\n    }\r\n\r\n    setCurrent (index: number, entry: TrackEntry) {\r\n        let current = this.expandToIndex(index);\r\n        if (current != null) {\r\n            let previous = current.previous;\r\n            current.previous = null;\r\n\r\n            if (entry.onEnd) entry.onEnd(index);\r\n            if (this.onEnd) this.onEnd(index);\r\n\r\n            entry.mixDuration = this.data.getMix(current.animation, entry.animation);\r\n            if (entry.mixDuration > 0) {\r\n                entry.mixTime = 0;\r\n                // If a mix is in progress, mix from the closest animation.\r\n                if (previous != null && current.mixTime / current.mixDuration < 0.5) {\r\n                    entry.previous = previous;\r\n                    previous = current;\r\n                } else\r\n                    entry.previous = current;\r\n            }\r\n        }\r\n\r\n        this.tracks[index] = entry;\r\n\r\n        if (entry.onStart) entry.onStart(index);\r\n        if (this.onStart) this.onStart(index);\r\n    }\r\n\r\n    /** @see #setAnimation(int, Animation, boolean) */\r\n    setAnimation (trackIndex: number, animationName: string, loop: boolean) {\r\n        let animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (animation == null) throw new Error(\"Animation not found: \" + animationName);\r\n        return this.setAnimationWith(trackIndex, animation, loop);\r\n    }\r\n\r\n    /** Set the current animation. Any queued animations are cleared. */\r\n    setAnimationWith (trackIndex: number, animation: Animation, loop: boolean) {\r\n        let current = this.expandToIndex(trackIndex);\r\n        if (current != null) this.freeAll(current.next);\r\n\r\n        let entry = new TrackEntry();\r\n        entry.animation = animation;\r\n        entry.loop = loop;\r\n        entry.endTime = animation.duration;\r\n        this.setCurrent(trackIndex, entry);\r\n        return entry;\r\n    }\r\n\r\n    /** {@link #addAnimation(int, Animation, boolean, float)} */\r\n    addAnimation (trackIndex: number, animationName: string, loop: boolean, delay: number) {\r\n        let animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (animation == null) throw new Error(\"Animation not found: \" + animationName);\r\n        return this.addAnimationWith(trackIndex, animation, loop, delay);\r\n    }\r\n\r\n    hasAnimation(animationName: string): boolean\r\n    {\r\n        let animation = this.data.skeletonData.findAnimation(animationName);\r\n        return animation !== null;\r\n    }\r\n\r\n    /** Adds an animation to be played delay seconds after the current or last queued animation.\r\n     * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */\r\n    addAnimationWith (trackIndex: number, animation: Animation, loop: boolean, delay: number) {\r\n        let entry = new TrackEntry();\r\n        entry.animation = animation;\r\n        entry.loop = loop;\r\n        entry.endTime = animation.duration;\r\n\r\n        let last = this.expandToIndex(trackIndex);\r\n        if (last != null) {\r\n            while (last.next != null)\r\n                last = last.next;\r\n            last.next = entry;\r\n        } else\r\n            this.tracks[trackIndex] = entry;\r\n\r\n        if (delay <= 0) {\r\n            if (last != null)\r\n                delay += last.endTime - this.data.getMix(last.animation, animation);\r\n            else\r\n                delay = 0;\r\n        }\r\n        entry.delay = delay;\r\n\r\n        return entry;\r\n    }\r\n\r\n    /** @return May be null. */\r\n    getCurrent (trackIndex: number) {\r\n        if (trackIndex >= this.tracks.length) return null;\r\n        return this.tracks[trackIndex];\r\n    }\r\n\r\n    onComplete: (trackIndex: number, loopCount: number) => any;\r\n    onEvent: (trackIndex: number, event: Event) => any;\r\n    onStart: (trackIndex: number) => any;\r\n    onEnd: (trackIndex: number) => any;\r\n\r\n    private static deprecatedWarning1: boolean = false;\r\n    setAnimationByName (trackIndex: number, animationName: string, loop: boolean) {\r\n        if (!AnimationState.deprecatedWarning1) {\r\n            AnimationState.deprecatedWarning1 = true;\r\n            console.warn(\"Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.\");\r\n        }\r\n        this.setAnimation(trackIndex, animationName, loop);\r\n    }\r\n\r\n    private static deprecatedWarning2: boolean = false;\r\n    addAnimationByName (trackIndex: number, animationName: string, loop: boolean, delay: number) {\r\n        if (!AnimationState.deprecatedWarning2) {\r\n            AnimationState.deprecatedWarning2 = true;\r\n            console.warn(\"Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.\");\r\n        }\r\n        this.addAnimation(trackIndex, animationName, loop, delay);\r\n    }\r\n\r\n    private static deprecatedWarning3: boolean = false;\r\n    hasAnimationByName (animationName: string): boolean\r\n    {\r\n        if (!AnimationState.deprecatedWarning3) {\r\n            AnimationState.deprecatedWarning3 = true;\r\n            console.warn(\"Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.\");\r\n        }\r\n        let animation = this.data.skeletonData.findAnimation(animationName);\r\n        return animation !== null;\r\n    }\r\n}\r\n\r\nexport class TrackEntry {\r\n    next: TrackEntry; previous: TrackEntry;\r\n    animation: Animation;\r\n    loop = false;\r\n    delay = 0; time = 0; lastTime = -1; endTime = 0; timeScale = 1;\r\n    mixTime = 0; mixDuration = 0;\r\n    mix = 1;\r\n\r\n    onComplete: (trackIndex: number, loopCount: number) => any;\r\n    onEvent: (trackIndex: number, event: Event) => any;\r\n    onStart: (trackIndex: number) => any;\r\n    onEnd: (trackIndex: number) => any;\r\n\r\n    reset () {\r\n        this.next = null;\r\n        this.previous = null;\r\n        this.animation = null;\r\n        this.timeScale = 1;\r\n        this.lastTime = -1; // Trigger events on frame zero.\r\n        this.time = 0;\r\n    }\r\n\r\n    /** Returns true if the current time is greater than the end time, regardless of looping. */\r\n    isComplete () : boolean {\r\n        return this.time >= this.endTime;\r\n    }\r\n}\r\n","import {Animation} from \"./Animation\";\nimport {SkeletonData} from \"./SkeletonData\";\nimport {Map} from \"./Utils\";\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nexport class AnimationStateData {\n    skeletonData: SkeletonData;\n    animationToMixTime: Map<number> = { };\n    defaultMix = 0;\n\n    constructor (skeletonData: SkeletonData) {\n        if (skeletonData == null) throw new Error(\"skeletonData cannot be null.\");\n        this.skeletonData = skeletonData;\n    }\n\n    setMix (fromName: string, toName: string, duration: number) {\n        let from = this.skeletonData.findAnimation(fromName);\n        if (from == null) throw new Error(\"Animation not found: \" + fromName);\n        let to = this.skeletonData.findAnimation(toName);\n        if (to == null) throw new Error(\"Animation not found: \" + toName);\n        this.setMixWith(from, to, duration);\n    }\n\n    private static deprecatedWarning1: boolean = false;\n    setMixByName(fromName: string, toName: string, duration: number) {\n        if (!AnimationStateData.deprecatedWarning1) {\n            AnimationStateData.deprecatedWarning1 = true;\n            console.warn(\"Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.\");\n        }\n        this.setMix(fromName, toName, duration);\n    }\n\n    setMixWith (from: Animation, to: Animation, duration: number) {\n        if (from == null) throw new Error(\"from cannot be null.\");\n        if (to == null) throw new Error(\"to cannot be null.\");\n        let key = from.name + to.name;\n        this.animationToMixTime[key] = duration;\n    }\n\n    getMix (from: Animation, to: Animation) {\n        let key = from.name + to.name;\n        let value = this.animationToMixTime[key];\n        return value === undefined ? this.defaultMix : value;\n    }\n}\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport enum BlendMode {\r\n    Normal,\r\n    Additive,\r\n    Multiply,\r\n    Screen\r\n}\r\n","import {Updatable} from \"./Updatable\";\r\nimport {BoneData} from \"./BoneData\";\r\nimport {Skeleton} from \"./Skeleton\";\r\nimport {MathUtils, Vector2} from \"./Utils\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class Bone implements Updatable {\r\n    static yDown: boolean = false;\r\n    //be careful! Spine b,c is c,b in pixi matrix\r\n    matrix = new PIXI.Matrix();\r\n\r\n    get worldX(): number {\r\n        return this.matrix.tx;\r\n    }\r\n\r\n    get worldY(): number {\r\n        return this.matrix.ty;\r\n    }\r\n\r\n    data: BoneData;\r\n    skeleton: Skeleton;\r\n    parent: Bone;\r\n    children = new Array<Bone>();\r\n    x = 0; y = 0; rotation = 0; scaleX = 0; scaleY = 0; shearX = 0; shearY = 0;\r\n    appliedRotation = 0;\r\n\r\n    worldSignX = 0; worldSignY = 0;\r\n\r\n    sorted = false;\r\n\r\n    /** @param parent May be null. */\r\n    constructor (data: BoneData, skeleton: Skeleton, parent: Bone) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n        this.data = data;\r\n        this.skeleton = skeleton;\r\n        this.parent = parent;\r\n        this.setToSetupPose();\r\n    }\r\n\r\n    /** Same as {@link #updateWorldTransform()}. This method exists for Bone to implement {@link Updatable}. */\r\n    update () {\r\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\r\n    }\r\n\r\n    /** Computes the world transform using the parent bone and this bone's local transform. */\r\n    updateWorldTransform () {\r\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\r\n    }\r\n\r\n    /** Computes the world transform using the parent bone and the specified local transform. */\r\n    updateWorldTransformWith (x: number, y: number, rotation: number, scaleX: number, scaleY: number, shearX: number, shearY: number) {\r\n        this.appliedRotation = rotation;\r\n\r\n        let rotationY = rotation + 90 + shearY;\r\n        let la = MathUtils.cosDeg(rotation + shearX) * scaleX, lb = MathUtils.cosDeg(rotationY) * scaleY;\r\n        let lc = MathUtils.sinDeg(rotation + shearX) * scaleX, ld = MathUtils.sinDeg(rotationY) * scaleY;\r\n\r\n        let parent = this.parent;\r\n        let m = this.matrix;\r\n        if (parent == null) { // Root bone.\r\n            let skeleton = this.skeleton;\r\n            if (skeleton.flipX) {\r\n                x = -x;\r\n                la = -la;\r\n                lb = -lb;\r\n            }\r\n            if (skeleton.flipY !== Bone.yDown) {\r\n                y = -y;\r\n                lc = -lc;\r\n                ld = -ld;\r\n            }\r\n            m.a = la;\r\n            m.c = lb;\r\n            m.b = lc;\r\n            m.d = ld;\r\n            m.tx = x;\r\n            m.ty = y;\r\n            this.worldSignX = MathUtils.signum(scaleX);\r\n            this.worldSignY = MathUtils.signum(scaleY);\r\n            return;\r\n        }\r\n\r\n        let pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;\r\n        m.tx = pa * x + pb * y + parent.matrix.tx;\r\n        m.ty = pc * x + pd * y + parent.matrix.ty;\r\n        this.worldSignX = parent.worldSignX * MathUtils.signum(scaleX);\r\n        this.worldSignY = parent.worldSignY * MathUtils.signum(scaleY);\r\n\r\n        if (this.data.inheritRotation && this.data.inheritScale) {\r\n            m.a = pa * la + pb * lc;\r\n            m.c = pa * lb + pb * ld;\r\n            m.b = pc * la + pd * lc;\r\n            m.d = pc * lb + pd * ld;\r\n        } else {\r\n            if (this.data.inheritRotation) { // No scale inheritance.\r\n                pa = 1;\r\n                pb = 0;\r\n                pc = 0;\r\n                pd = 1;\r\n                do {\r\n                    let cos = MathUtils.cosDeg(parent.appliedRotation), sin = MathUtils.sinDeg(parent.appliedRotation);\r\n                    let temp = pa * cos + pb * sin;\r\n                    pb = pb * cos - pa * sin;\r\n                    pa = temp;\r\n                    temp = pc * cos + pd * sin;\r\n                    pd = pd * cos - pc * sin;\r\n                    pc = temp;\r\n\r\n                    if (!parent.data.inheritRotation) break;\r\n                    parent = parent.parent;\r\n                } while (parent != null);\r\n                m.a = pa * la + pb * lc;\r\n                m.c = pa * lb + pb * ld;\r\n                m.b = pc * la + pd * lc;\r\n                m.d = pc * lb + pd * ld;\r\n            } else if (this.data.inheritScale) { // No rotation inheritance.\r\n                pa = 1;\r\n                pb = 0;\r\n                pc = 0;\r\n                pd = 1;\r\n                do {\r\n                    let cos = MathUtils.cosDeg(parent.appliedRotation), sin = MathUtils.sinDeg(parent.appliedRotation);\r\n                    let psx = parent.scaleX, psy = parent.scaleY;\r\n                    let za = cos * psx, zb = sin * psy, zc = sin * psx, zd = cos * psy;\r\n                    let temp = pa * za + pb * zc;\r\n                    pb = pb * zd - pa * zb;\r\n                    pa = temp;\r\n                    temp = pc * za + pd * zc;\r\n                    pd = pd * zd - pc * zb;\r\n                    pc = temp;\r\n\r\n                    if (psx >= 0) sin = -sin;\r\n                    temp = pa * cos + pb * sin;\r\n                    pb = pb * cos - pa * sin;\r\n                    pa = temp;\r\n                    temp = pc * cos + pd * sin;\r\n                    pd = pd * cos - pc * sin;\r\n                    pc = temp;\r\n\r\n                    if (!parent.data.inheritScale) break;\r\n                    parent = parent.parent;\r\n                } while (parent != null);\r\n                m.a = pa * la + pb * lc;\r\n                m.c = pa * lb + pb * ld;\r\n                m.b = pc * la + pd * lc;\r\n                m.d = pc * lb + pd * ld;\r\n            } else {\r\n                m.a = la;\r\n                m.c = lb;\r\n                m.b = lc;\r\n                m.d = ld;\r\n            }\r\n            if (this.skeleton.flipX) {\r\n                m.a = -m.a;\r\n                m.c = -m.c;\r\n            }\r\n            if (this.skeleton.flipY !== Bone.yDown) {\r\n                m.b = -m.b;\r\n                m.d = -m.d;\r\n            }\r\n        }\r\n    }\r\n\r\n    setToSetupPose () {\r\n        let data = this.data;\r\n        this.x = data.x;\r\n        this.y = data.y;\r\n        this.rotation = data.rotation;\r\n        this.scaleX = data.scaleX;\r\n        this.scaleY = data.scaleY;\r\n        this.shearX = data.shearX;\r\n        this.shearY = data.shearY;\r\n    }\r\n\r\n    getWorldRotationX () {\r\n        return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\r\n    }\r\n\r\n    getWorldRotationY () {\r\n        return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\r\n    }\r\n\r\n    getWorldScaleX () {\r\n        return Math.sqrt(this.matrix.a * this.matrix.a + this.matrix.b * this.matrix.b) * this.worldSignX;\r\n    }\r\n\r\n    getWorldScaleY () {\r\n        return Math.sqrt(this.matrix.c * this.matrix.c + this.matrix.d * this.matrix.d) * this.worldSignY;\r\n    }\r\n\r\n    worldToLocalRotationX () {\r\n        let parent = this.parent;\r\n        if (parent == null) return this.rotation;\r\n        let pm = parent.matrix;\r\n        let pa = pm.a, pb = pm.c, pc = pm.b, pd = pm.d, a = this.matrix.a, c = this.matrix.b;\r\n        return Math.atan2(pa * c - pc * a, pd * a - pb * c) * MathUtils.radDeg;\r\n    }\r\n\r\n    worldToLocalRotationY () {\r\n        let parent = this.parent;\r\n        if (parent == null) return this.rotation;\r\n        let pm = parent.matrix;\r\n        let pa = pm.a, pb = pm.b, pc = pm.c, pd = pm.d, b = this.matrix.c, d = this.matrix.d;\r\n        return Math.atan2(pa * d - pc * b, pd * b - pb * d) * MathUtils.radDeg;\r\n    }\r\n\r\n    rotateWorld (degrees: number) {\r\n        let m = this.matrix;\r\n        let a = this.matrix.a, b = m.c, c = m.b, d = m.d;\r\n        let cos = MathUtils.cosDeg(degrees), sin = MathUtils.sinDeg(degrees);\r\n        m.a = cos * a - sin * c;\r\n        m.c = cos * b - sin * d;\r\n        m.b = sin * a + cos * c;\r\n        m.d = sin * b + cos * d;\r\n    }\r\n\r\n    /** Computes the local transform from the world transform. This can be useful to perform processing on the local transform\r\n     * after the world transform has been modified directly (eg, by a constraint).\r\n     * <p>\r\n     * Some redundant information is lost by the world transform, such as -1,-1 scale versus 180 rotation. The computed local\r\n     * transform values may differ from the original values but are functionally the same. */\r\n    updateLocalTransform () {\r\n        let parent = this.parent;\r\n        let m = this.matrix;\r\n        if (parent == null) {\r\n            this.x = m.tx;\r\n            this.y = m.ty;\r\n            this.rotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\r\n            this.scaleX = Math.sqrt(m.a * m.a + m.b * m.b);\r\n            this.scaleY = Math.sqrt(m.c * m.c + m.d * m.d);\r\n            let det = m.a * m.d - m.b * m.c;\r\n            this.shearX = 0;\r\n            this.shearY = Math.atan2(m.a * m.c + m.b * m.d, det) * MathUtils.radDeg;\r\n            return;\r\n        }\r\n        let pm = parent.matrix;\r\n        let pa = pm.a, pb = pm.c, pc = pm.b, pd = pm.d;\r\n        let pid = 1 / (pa * pd - pb * pc);\r\n        let dx = m.tx - pm.tx, dy = m.ty - pm.ty;\r\n        this.x = (dx * pd * pid - dy * pb * pid);\r\n        this.y = (dy * pa * pid - dx * pc * pid);\r\n        let ia = pid * pd;\r\n        let id = pid * pa;\r\n        let ib = pid * pb;\r\n        let ic = pid * pc;\r\n        let ra = ia * m.a - ib * m.b;\r\n        let rb = ia * m.c - ib * m.d;\r\n        let rc = id * m.b - ic * m.a;\r\n        let rd = id * m.d - ic * m.c;\r\n        this.shearX = 0;\r\n        this.scaleX = Math.sqrt(ra * ra + rc * rc);\r\n        if (this.scaleX > 0.0001) {\r\n            let det = ra * rd - rb * rc;\r\n            this.scaleY = det / this.scaleX;\r\n            this.shearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\r\n            this.rotation = Math.atan2(rc, ra) * MathUtils.radDeg;\r\n        } else {\r\n            this.scaleX = 0;\r\n            this.scaleY = Math.sqrt(rb * rb + rd * rd);\r\n            this.shearY = 0;\r\n            this.rotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\r\n        }\r\n        this.appliedRotation = this.rotation;\r\n    }\r\n\r\n    worldToLocal (world: Vector2) {\r\n        let m = this.matrix;\r\n        let a = m.a, b = m.c, c = m.b, d = m.d;\r\n        let invDet = 1 / (a * d - b * c);\r\n        let x = world.x - m.tx, y = world.y - m.ty;\r\n        world.x = (x * d * invDet - y * b * invDet);\r\n        world.y = (y * a * invDet - x * c * invDet);\r\n        return world;\r\n    }\r\n\r\n    localToWorld (local: Vector2) {\r\n        let m = this.matrix;\r\n        let x = local.x, y = local.y;\r\n        local.x = x * m.a + y * m.c + m.tx;\r\n        local.y = x * m.b + y * m.d + m.ty;\r\n        return local;\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class BoneData {\r\n    index: number;\r\n    name: string;\r\n    parent: BoneData;\r\n    length: number;\r\n    x = 0; y = 0; rotation = 0; scaleX = 1; scaleY = 1; shearX = 0; shearY = 0;\r\n    inheritRotation = true; inheritScale = true;\r\n\r\n    constructor (index: number, name: string, parent: BoneData) {\r\n        if (index < 0) throw new Error(\"index must be >= 0.\");\r\n        if (name == null) throw new Error(\"name cannot be null.\");\r\n        this.index = index;\r\n        this.name = name;\r\n        this.parent = parent;\r\n    }\r\n}\r\n","import {EventData} from \"./EventData\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class Event {\r\n    data: EventData;\r\n    intValue: number;\r\n    floatValue: number;\r\n    stringValue: string;\r\n    time: number;\r\n\r\n    constructor (time: number, data: EventData) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        this.time = time;\r\n        this.data = data;\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class EventData {\r\n    name: string;\r\n    intValue: number;\r\n    floatValue: number;\r\n    stringValue: string;\r\n\r\n    constructor (name: string) {\r\n        this.name = name;\r\n    }\r\n}\r\n","import {Updatable} from \"./Updatable\";\r\nimport {IkConstraintData} from \"./IkConstraintData\";\r\nimport {Bone} from \"./Bone\";\r\nimport {Skeleton} from \"./Skeleton\";\r\nimport {MathUtils} from \"./Utils\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class IkConstraint implements Updatable {\r\n    data: IkConstraintData;\r\n    bones: Array<Bone>;\r\n    target: Bone;\r\n    mix = 1;\r\n    bendDirection = 0;\r\n\r\n    level = 0;\r\n\r\n    constructor (data: IkConstraintData, skeleton: Skeleton) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n        this.data = data;\r\n        this.mix = data.mix;\r\n        this.bendDirection = data.bendDirection;\r\n\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0; i < data.bones.length; i++)\r\n            this.bones.push(skeleton.findBone(data.bones[i].name));\r\n        this.target = skeleton.findBone(data.target.name);\r\n    }\r\n\r\n    apply () {\r\n        this.update();\r\n    }\r\n\r\n    update () {\r\n        let target = this.target;\r\n        let bones = this.bones;\r\n        switch (bones.length) {\r\n        case 1:\r\n            this.apply1(bones[0], target.worldX, target.worldY, this.mix);\r\n            break;\r\n        case 2:\r\n            this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);\r\n            break;\r\n        }\r\n    }\r\n\r\n    /** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\r\n     * coordinate system. */\r\n    apply1 (bone: Bone, targetX: number, targetY: number, alpha: number) {\r\n        let pp = bone.parent.matrix;\r\n        let id = 1 / (pp.a * pp.d - pp.b * pp.c);\r\n        let x = targetX - pp.tx, y = targetY - pp.ty;\r\n        let tx = (x * pp.d - y * pp.c) * id - bone.x, ty = (y * pp.a - x * pp.b) * id - bone.y;\r\n        let rotationIK = Math.atan2(ty, tx) * MathUtils.radDeg - bone.shearX - bone.rotation;\r\n        if (bone.scaleX < 0) rotationIK += 180;\r\n        if (rotationIK > 180)\r\n            rotationIK -= 360;\r\n        else if (rotationIK < -180) rotationIK += 360;\r\n        bone.updateWorldTransformWith(bone.x, bone.y, bone.rotation + rotationIK * alpha, bone.scaleX, bone.scaleY, bone.shearX,\r\n            bone.shearY);\r\n    }\r\n\r\n    /** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\r\n     * target is specified in the world coordinate system.\r\n     * @param child A direct descendant of the parent bone. */\r\n    apply2 (parent: Bone, child: Bone, targetX: number, targetY: number, bendDir: number, alpha: number) {\r\n        if (alpha == 0) {\r\n            child.updateWorldTransform();\r\n            return;\r\n        }\r\n        let px = parent.x, py = parent.y, psx = parent.scaleX, psy = parent.scaleY, csx = child.scaleX;\r\n        let os1 = 0, os2 = 0, s2 = 0;\r\n        if (psx < 0) {\r\n            psx = -psx;\r\n            os1 = 180;\r\n            s2 = -1;\r\n        } else {\r\n            os1 = 0;\r\n            s2 = 1;\r\n        }\r\n        if (psy < 0) {\r\n            psy = -psy;\r\n            s2 = -s2;\r\n        }\r\n        if (csx < 0) {\r\n            csx = -csx;\r\n            os2 = 180;\r\n        } else\r\n            os2 = 0;\r\n        let pm = parent.matrix;\r\n        let cx = child.x, cy = 0, cwx = 0, cwy = 0, a = pm.a, b = pm.c, c = pm.b, d = pm.d;\r\n        let u = Math.abs(psx - psy) <= 0.0001;\r\n        if (!u) {\r\n            cy = 0;\r\n            cwx = a * cx + pm.tx;\r\n            cwy = c * cx + pm.ty;\r\n        } else {\r\n            cy = child.y;\r\n            cwx = a * cx + b * cy + pm.tx;\r\n            cwy = c * cx + d * cy + pm.ty;\r\n        }\r\n        let pp = parent.parent;\r\n        let ppm = parent.parent.matrix;\r\n        a = ppm.a;\r\n        b = ppm.c;\r\n        c = ppm.b;\r\n        d = ppm.d;\r\n        let id = 1 / (a * d - b * c), x = targetX - ppm.tx, y = targetY - ppm.ty;\r\n        let tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py;\r\n        x = cwx - ppm.tx;\r\n        y = cwy - ppm.ty;\r\n        let dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;\r\n        let l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1 = 0, a2 = 0;\r\n        outer:\r\n        if (u) {\r\n            l2 *= psx;\r\n            let cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);\r\n            if (cos < -1)\r\n                cos = -1;\r\n            else if (cos > 1) cos = 1;\r\n            a2 = Math.acos(cos) * bendDir;\r\n            a = l1 + l2 * cos;\r\n            b = l2 * Math.sin(a2);\r\n            a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\r\n        } else {\r\n            a = psx * l2;\r\n            b = psy * l2;\r\n            let aa = a * a, bb = b * b, dd = tx * tx + ty * ty, ta = Math.atan2(ty, tx);\r\n            c = bb * l1 * l1 + aa * dd - aa * bb;\r\n            let c1 = -2 * bb * l1, c2 = bb - aa;\r\n            d = c1 * c1 - 4 * c2 * c;\r\n            if (d >= 0) {\r\n                let q = Math.sqrt(d);\r\n                if (c1 < 0) q = -q;\r\n                q = -(c1 + q) / 2;\r\n                let r0 = q / c2, r1 = c / q;\r\n                let r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\r\n                if (r * r <= dd) {\r\n                    y = Math.sqrt(dd - r * r) * bendDir;\r\n                    a1 = ta - Math.atan2(y, r);\r\n                    a2 = Math.atan2(y / psy, (r - l1) / psx);\r\n                    break outer;\r\n                }\r\n            }\r\n            let minAngle = 0, minDist = Number.MAX_VALUE, minX = 0, minY = 0;\r\n            let maxAngle = 0, maxDist = 0, maxX = 0, maxY = 0;\r\n            x = l1 + a;\r\n            d = x * x;\r\n            if (d > maxDist) {\r\n                maxAngle = 0;\r\n                maxDist = d;\r\n                maxX = x;\r\n            }\r\n            x = l1 - a;\r\n            d = x * x;\r\n            if (d < minDist) {\r\n                minAngle = MathUtils.PI;\r\n                minDist = d;\r\n                minX = x;\r\n            }\r\n            let angle = Math.acos(-a * l1 / (aa - bb));\r\n            x = a * Math.cos(angle) + l1;\r\n            y = b * Math.sin(angle);\r\n            d = x * x + y * y;\r\n            if (d < minDist) {\r\n                minAngle = angle;\r\n                minDist = d;\r\n                minX = x;\r\n                minY = y;\r\n            }\r\n            if (d > maxDist) {\r\n                maxAngle = angle;\r\n                maxDist = d;\r\n                maxX = x;\r\n                maxY = y;\r\n            }\r\n            if (dd <= (minDist + maxDist) / 2) {\r\n                a1 = ta - Math.atan2(minY * bendDir, minX);\r\n                a2 = minAngle * bendDir;\r\n            } else {\r\n                a1 = ta - Math.atan2(maxY * bendDir, maxX);\r\n                a2 = maxAngle * bendDir;\r\n            }\r\n        }\r\n        let os = Math.atan2(cy, cx) * s2;\r\n        let rotation = parent.rotation;\r\n        a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\r\n        if (a1 > 180)\r\n            a1 -= 360;\r\n        else if (a1 < -180) a1 += 360;\r\n        parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, parent.scaleX, parent.scaleY, 0, 0);\r\n        rotation = child.rotation;\r\n        a2 = ((a2 + os) * MathUtils.radDeg - child.shearX) * s2 + os2 - rotation;\r\n        if (a2 > 180)\r\n            a2 -= 360;\r\n        else if (a2 < -180) a2 += 360;\r\n        child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.scaleX, child.scaleY, child.shearX, child.shearY);\r\n    }\r\n}\r\n","import {BoneData} from \"./BoneData\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class IkConstraintData {\r\n    name: string;\r\n    bones = new Array<BoneData>();\r\n    target: BoneData;\r\n    bendDirection = 1;\r\n    mix = 1;\r\n\r\n    constructor (name: string) {\r\n        this.name = name;\r\n    }\r\n}\r\n","import {Updatable} from \"./Updatable\";\r\nimport {PathConstraintData, SpacingMode, RotateMode, PositionMode} from \"./PathConstraintData\";\r\nimport {Bone} from \"./Bone\";\r\nimport {Slot} from \"./Slot\";\r\nimport {Skeleton} from \"./Skeleton\";\r\nimport {PathAttachment} from \"./attachments\";\r\nimport {Utils, MathUtils} from \"./Utils\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class PathConstraint implements Updatable {\r\n    static NONE = -1; static BEFORE = -2; static AFTER = -3;\r\n\r\n    data: PathConstraintData;\r\n    bones: Array<Bone>;\r\n    target: Slot;\r\n    position = 0; spacing = 0; rotateMix = 0; translateMix = 0;\r\n\r\n    spaces = new Array<number>(); positions = new Array<number>();\r\n    world = new Array<number>(); curves = new Array<number>(); lengths = new Array<number>();\r\n    segments = new Array<number>();\r\n\r\n    constructor (data: PathConstraintData, skeleton: Skeleton) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n        this.data = data;\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0, n = data.bones.length; i < n; i++)\r\n            this.bones.push(skeleton.findBone(data.bones[i].name));\r\n        this.target = skeleton.findSlot(data.target.name);\r\n        this.position = data.position;\r\n        this.spacing = data.spacing;\r\n        this.rotateMix = data.rotateMix;\r\n        this.translateMix = data.translateMix;\r\n    }\r\n\r\n    apply () {\r\n        this.update();\r\n    }\r\n\r\n    update () {\r\n        let attachment = this.target.getAttachment();\r\n        if (!(attachment instanceof PathAttachment)) return;\r\n\r\n        let rotateMix = this.rotateMix, translateMix = this.translateMix;\r\n        let translate = translateMix > 0, rotate = rotateMix > 0;\r\n        if (!translate && !rotate) return;\r\n\r\n        let data = this.data;\r\n        let spacingMode = data.spacingMode;\r\n        let lengthSpacing = spacingMode == SpacingMode.Length;\r\n        let rotateMode = data.rotateMode;\r\n        let tangents = rotateMode == RotateMode.Tangent, scale = rotateMode == RotateMode.ChainScale;\r\n        let boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;\r\n        let bones = this.bones;\r\n        let spaces = Utils.setArraySize(this.spaces, spacesCount), lengths: Array<number> = null;\r\n        let spacing = this.spacing;\r\n        if (scale || lengthSpacing) {\r\n            if (scale) lengths = Utils.setArraySize(this.lengths, boneCount);\r\n            for (let i = 0, n = spacesCount - 1; i < n;) {\r\n                let bone = bones[i];\r\n                let m = bone.matrix;\r\n                let length = bone.data.length, x = length * m.a, y = length * m.b;\r\n                length = Math.sqrt(x * x + y * y);\r\n                if (scale) lengths[i] = length;\r\n                spaces[++i] = lengthSpacing ? Math.max(0, length + spacing) : spacing;\r\n            }\r\n        } else {\r\n            for (let i = 1; i < spacesCount; i++)\r\n                spaces[i] = spacing;\r\n        }\r\n\r\n        let positions = this.computeWorldPositions(<PathAttachment>attachment, spacesCount, tangents,\r\n            data.positionMode == PositionMode.Percent, spacingMode == SpacingMode.Percent);\r\n        let skeleton = this.target.bone.skeleton;\r\n        let skeletonX = skeleton.x, skeletonY = skeleton.y;\r\n        let boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;\r\n        let tip = rotateMode == RotateMode.Chain && offsetRotation == 0;\r\n        for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\r\n            let bone = bones[i];\r\n            let m = bone.matrix;\r\n            m.tx += (boneX - skeletonX - bone.worldX) * translateMix;\r\n            m.ty += (boneY - skeletonY - bone.worldY) * translateMix;\r\n            let x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;\r\n            if (scale) {\r\n                let length = lengths[i];\r\n                if (length != 0) {\r\n                    let s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * rotateMix + 1;\r\n                    m.a *= s;\r\n                    m.b *= s;\r\n                }\r\n            }\r\n            boneX = x;\r\n            boneY = y;\r\n            if (rotate) {\r\n                let a = m.a, b = m.c, c = m.b, d = m.d, r = 0, cos = 0, sin = 0;\r\n                if (tangents)\r\n                    r = positions[p - 1];\r\n                else if (spaces[i + 1] == 0)\r\n                    r = positions[p + 2];\r\n                else\r\n                    r = Math.atan2(dy, dx);\r\n                r -= Math.atan2(c, a) - offsetRotation * MathUtils.degRad;\r\n                if (tip) {\r\n                    cos = Math.cos(r);\r\n                    sin = Math.sin(r);\r\n                    let length = bone.data.length;\r\n                    boneX += (length * (cos * a - sin * c) - dx) * rotateMix;\r\n                    boneY += (length * (sin * a + cos * c) - dy) * rotateMix;\r\n                }\r\n                if (r > MathUtils.PI)\r\n                    r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI) //\r\n                    r += MathUtils.PI2;\r\n                r *= rotateMix;\r\n                cos = Math.cos(r);\r\n                sin = Math.sin(r);\r\n                m.a = cos * a - sin * c;\r\n                m.c = cos * b - sin * d;\r\n                m.b = sin * a + cos * c;\r\n                m.d = sin * b + cos * d;\r\n            }\r\n        }\r\n    }\r\n\r\n    computeWorldPositions (path: PathAttachment, spacesCount: number, tangents: boolean, percentPosition: boolean,\r\n        percentSpacing: boolean) {\r\n        let target = this.target;\r\n        let position = this.position;\r\n        let spaces = this.spaces, out = Utils.setArraySize(this.positions, spacesCount * 3 + 2), world: Array<number> = null;\r\n        let closed = path.closed;\r\n        let verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;\r\n\r\n        if (!path.constantSpeed) {\r\n            let lengths = path.lengths;\r\n            curveCount -= closed ? 1 : 2;\r\n            let pathLength = lengths[curveCount];\r\n            if (percentPosition) position *= pathLength;\r\n            if (percentSpacing) {\r\n                for (let i = 0; i < spacesCount; i++)\r\n                    spaces[i] *= pathLength;\r\n            }\r\n            world = Utils.setArraySize(this.world, 8);\r\n            for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\r\n                let space = spaces[i];\r\n                position += space;\r\n                let p = position;\r\n\r\n                if (closed) {\r\n                    p %= pathLength;\r\n                    if (p < 0) p += pathLength;\r\n                    curve = 0;\r\n                } else if (p < 0) {\r\n                    if (prevCurve != PathConstraint.BEFORE) {\r\n                        prevCurve = PathConstraint.BEFORE;\r\n                        path.computeWorldVerticesWith(target, 2, 4, world, 0);\r\n                    }\r\n                    this.addBeforePosition(p, world, 0, out, o);\r\n                    continue;\r\n                } else if (p > pathLength) {\r\n                    if (prevCurve != PathConstraint.AFTER) {\r\n                        prevCurve = PathConstraint.AFTER;\r\n                        path.computeWorldVerticesWith(target, verticesLength - 6, 4, world, 0);\r\n                    }\r\n                    this.addAfterPosition(p - pathLength, world, 0, out, o);\r\n                    continue;\r\n                }\r\n\r\n                // Determine curve containing position.\r\n                for (;; curve++) {\r\n                    let length = lengths[curve];\r\n                    if (p > length) continue;\r\n                    if (curve == 0)\r\n                        p /= length;\r\n                    else {\r\n                        let prev = lengths[curve - 1];\r\n                        p = (p - prev) / (length - prev);\r\n                    }\r\n                    break;\r\n                }\r\n                if (curve != prevCurve) {\r\n                    prevCurve = curve;\r\n                    if (closed && curve == curveCount) {\r\n                        path.computeWorldVerticesWith(target, verticesLength - 4, 4, world, 0);\r\n                        path.computeWorldVerticesWith(target, 0, 4, world, 4);\r\n                    } else\r\n                        path.computeWorldVerticesWith(target, curve * 6 + 2, 8, world, 0);\r\n                }\r\n                this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o,\r\n                    tangents || (i > 0 && space == 0));\r\n            }\r\n            return out;\r\n        }\r\n\r\n        // World vertices.\r\n        if (closed) {\r\n            verticesLength += 2;\r\n            world = Utils.setArraySize(this.world, verticesLength);\r\n            path.computeWorldVerticesWith(target, 2, verticesLength - 4, world, 0);\r\n            path.computeWorldVerticesWith(target, 0, 2, world, verticesLength - 4);\r\n            world[verticesLength - 2] = world[0];\r\n            world[verticesLength - 1] = world[1];\r\n        } else {\r\n            curveCount--;\r\n            verticesLength -= 4;\r\n            world = Utils.setArraySize(this.world, verticesLength);\r\n            path.computeWorldVerticesWith(target, 2, verticesLength, world, 0);\r\n        }\r\n\r\n        // Curve lengths.\r\n        let curves = Utils.setArraySize(this.curves, curveCount);\r\n        let pathLength = 0;\r\n        let x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;\r\n        let tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;\r\n        for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\r\n            cx1 = world[w];\r\n            cy1 = world[w + 1];\r\n            cx2 = world[w + 2];\r\n            cy2 = world[w + 3];\r\n            x2 = world[w + 4];\r\n            y2 = world[w + 5];\r\n            tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\r\n            tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\r\n            dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\r\n            dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\r\n            ddfx = tmpx * 2 + dddfx;\r\n            ddfy = tmpy * 2 + dddfy;\r\n            dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\r\n            dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            ddfx += dddfx;\r\n            ddfy += dddfy;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            dfx += ddfx + dddfx;\r\n            dfy += ddfy + dddfy;\r\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n            curves[i] = pathLength;\r\n            x1 = x2;\r\n            y1 = y2;\r\n        }\r\n        if (percentPosition) position *= pathLength;\r\n        if (percentSpacing) {\r\n            for (let i = 0; i < spacesCount; i++)\r\n                spaces[i] *= pathLength;\r\n        }\r\n\r\n        let segments = this.segments;\r\n        let curveLength = 0;\r\n        for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\r\n            let space = spaces[i];\r\n            position += space;\r\n            let p = position;\r\n\r\n            if (closed) {\r\n                p %= pathLength;\r\n                if (p < 0) p += pathLength;\r\n                curve = 0;\r\n            } else if (p < 0) {\r\n                this.addBeforePosition(p, world, 0, out, o);\r\n                continue;\r\n            } else if (p > pathLength) {\r\n                this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\r\n                continue;\r\n            }\r\n\r\n            // Determine curve containing position.\r\n            for (;; curve++) {\r\n                let length = curves[curve];\r\n                if (p > length) continue;\r\n                if (curve == 0)\r\n                    p /= length;\r\n                else {\r\n                    let prev = curves[curve - 1];\r\n                    p = (p - prev) / (length - prev);\r\n                }\r\n                break;\r\n            }\r\n\r\n            // Curve segment lengths.\r\n            if (curve != prevCurve) {\r\n                prevCurve = curve;\r\n                let ii = curve * 6;\r\n                x1 = world[ii];\r\n                y1 = world[ii + 1];\r\n                cx1 = world[ii + 2];\r\n                cy1 = world[ii + 3];\r\n                cx2 = world[ii + 4];\r\n                cy2 = world[ii + 5];\r\n                x2 = world[ii + 6];\r\n                y2 = world[ii + 7];\r\n                tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\r\n                tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\r\n                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\r\n                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\r\n                ddfx = tmpx * 2 + dddfx;\r\n                ddfy = tmpy * 2 + dddfy;\r\n                dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\r\n                dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\r\n                curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\r\n                segments[0] = curveLength;\r\n                for (ii = 1; ii < 8; ii++) {\r\n                    dfx += ddfx;\r\n                    dfy += ddfy;\r\n                    ddfx += dddfx;\r\n                    ddfy += dddfy;\r\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                    segments[ii] = curveLength;\r\n                }\r\n                dfx += ddfx;\r\n                dfy += ddfy;\r\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                segments[8] = curveLength;\r\n                dfx += ddfx + dddfx;\r\n                dfy += ddfy + dddfy;\r\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                segments[9] = curveLength;\r\n                segment = 0;\r\n            }\r\n\r\n            // Weight by segment length.\r\n            p *= curveLength;\r\n            for (;; segment++) {\r\n                let length = segments[segment];\r\n                if (p > length) continue;\r\n                if (segment == 0)\r\n                    p /= length;\r\n                else {\r\n                    let prev = segments[segment - 1];\r\n                    p = segment + (p - prev) / (length - prev);\r\n                }\r\n                break;\r\n            }\r\n            this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\r\n        }\r\n        return out;\r\n    }\r\n\r\n    addBeforePosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\r\n        let x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);\r\n        out[o] = x1 + p * Math.cos(r);\r\n        out[o + 1] = y1 + p * Math.sin(r);\r\n        out[o + 2] = r;\r\n    }\r\n\r\n    addAfterPosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\r\n        let x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);\r\n        out[o] = x1 + p * Math.cos(r);\r\n        out[o + 1] = y1 + p * Math.sin(r);\r\n        out[o + 2] = r;\r\n    }\r\n\r\n    addCurvePosition (p: number, x1: number, y1: number, cx1: number, cy1: number, cx2: number, cy2: number, x2: number, y2: number,\r\n        out: Array<number>, o: number, tangents: boolean) {\r\n        if (p == 0) p = 0.0001;\r\n        let tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;\r\n        let ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;\r\n        let x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\r\n        out[o] = x;\r\n        out[o + 1] = y;\r\n        if (tangents) out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\r\n    }\r\n}\r\n","import {BoneData} from \"./BoneData\";\r\nimport {SlotData} from \"./SlotData\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class PathConstraintData {\r\n    name: string;\r\n    bones = new Array<BoneData>();\r\n    target: SlotData;\r\n    positionMode: PositionMode;\r\n    spacingMode: SpacingMode;\r\n    rotateMode: RotateMode;\r\n    offsetRotation: number;\r\n    position: number; spacing: number; rotateMix: number; translateMix: number;\r\n\r\n    constructor (name: string) {\r\n        this.name = name;\r\n    }\r\n}\r\n\r\nexport enum PositionMode {\r\n    Fixed, Percent\r\n}\r\n\r\nexport enum SpacingMode {\r\n    Length, Fixed, Percent\r\n}\r\n\r\nexport enum RotateMode {\r\n    Tangent, Chain, ChainScale\r\n}\r\n","import {Slot} from \"./Slot\";\r\nimport {Bone} from \"./Bone\";\r\nimport {IkConstraint} from \"./IkConstraint\";\r\nimport {TransformConstraint} from \"./TransformConstraint\";\r\nimport {PathConstraint} from \"./PathConstraint\";\r\nimport {Color, Utils, Vector2} from \"./Utils\";\r\nimport {Skin} from \"./Skin\";\r\nimport {SkeletonData} from \"./SkeletonData\";\r\nimport {Updatable} from \"./Updatable\";\r\nimport {Attachment, PathAttachment, RegionAttachment, MeshAttachment} from \"./attachments\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class Skeleton {\r\n    data: SkeletonData;\r\n    bones: Array<Bone>;\r\n    slots: Array<Slot>;\r\n    drawOrder: Array<Slot>;\r\n    ikConstraints: Array<IkConstraint>; ikConstraintsSorted: Array<IkConstraint>;\r\n    transformConstraints: Array<TransformConstraint>;\r\n    pathConstraints: Array<PathConstraint>;\r\n    _updateCache = new Array<Updatable>();\r\n    skin: Skin;\r\n    color: Color;\r\n    time = 0;\r\n    flipX = false; flipY = false;\r\n    x = 0; y = 0;\r\n\r\n    constructor (data: SkeletonData) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        this.data = data;\r\n\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0; i < data.bones.length; i++) {\r\n            let boneData = data.bones[i];\r\n            let bone: Bone;\r\n            if (boneData.parent == null)\r\n                bone = new Bone(boneData, this, null);\r\n            else {\r\n                let parent = this.bones[boneData.parent.index];\r\n                bone = new Bone(boneData, this, parent);\r\n                parent.children.push(bone);\r\n            }\r\n            this.bones.push(bone);\r\n        }\r\n\r\n        this.slots = new Array<Slot>();\r\n        this.drawOrder = new Array<Slot>();\r\n        for (let i = 0; i < data.slots.length; i++) {\r\n            let slotData = data.slots[i];\r\n            let bone = this.bones[slotData.boneData.index];\r\n            let slot = new Slot(slotData, bone);\r\n            this.slots.push(slot);\r\n            this.drawOrder.push(slot);\r\n        }\r\n\r\n        this.ikConstraints = new Array<IkConstraint>();\r\n        this.ikConstraintsSorted = new Array<IkConstraint>();\r\n        for (let i = 0; i < data.ikConstraints.length; i++) {\r\n            let ikConstraintData = data.ikConstraints[i];\r\n            this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\r\n        }\r\n\r\n        this.transformConstraints = new Array<TransformConstraint>();\r\n        for (let i = 0; i < data.transformConstraints.length; i++) {\r\n            let transformConstraintData = data.transformConstraints[i];\r\n            this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\r\n        }\r\n\r\n        this.pathConstraints = new Array<PathConstraint>();\r\n        for (let i = 0; i < data.pathConstraints.length; i++) {\r\n            let pathConstraintData = data.pathConstraints[i];\r\n            this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\r\n        }\r\n\r\n        this.color = new Color(1, 1, 1, 1);\r\n        this.updateCache();\r\n    }\r\n\r\n    updateCache () {\r\n        let updateCache = this._updateCache;\r\n        updateCache.length = 0;\r\n\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++)\r\n            bones[i].sorted = false;\r\n\r\n        // IK first, lowest hierarchy depth first.\r\n        let ikConstraints = this.ikConstraintsSorted;\r\n        ikConstraints.length = 0;\r\n        for (let i = 0; i < this.ikConstraints.length; i++)\r\n            ikConstraints.push(this.ikConstraints[i]);\r\n        let ikCount = ikConstraints.length;\r\n        for (let i = 0, level = 0, n = ikCount; i < n; i++) {\r\n            let ik = ikConstraints[i];\r\n            let bone = ik.bones[0].parent;\r\n            for (level = 0; bone != null; level++)\r\n                bone = bone.parent;\r\n            ik.level = level;\r\n        }\r\n        for (let i = 1, ii = 0; i < ikCount; i++) {\r\n            let ik = ikConstraints[i];\r\n            let level = ik.level;\r\n            for (ii = i - 1; ii >= 0; ii--) {\r\n                let other = ikConstraints[ii];\r\n                if (other.level < level) break;\r\n                ikConstraints[ii + 1] = other;\r\n            }\r\n            ikConstraints[ii + 1] = ik;\r\n        }\r\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n            let constraint = ikConstraints[i];\r\n            let target = constraint.target;\r\n            this.sortBone(target);\r\n\r\n            let constrained = constraint.bones;\r\n            let parent = constrained[0];\r\n            this.sortBone(parent);\r\n\r\n            updateCache.push(constraint);\r\n\r\n            this.sortReset(parent.children);\r\n            constrained[constrained.length - 1].sorted = true;\r\n        }\r\n\r\n        let pathConstraints = this.pathConstraints;\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n            let constraint = pathConstraints[i];\r\n\r\n            let slot = constraint.target;\r\n            let slotIndex = slot.data.index;\r\n            let slotBone = slot.bone;\r\n            if (this.skin != null) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\r\n            if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)\r\n                this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\r\n            for (let ii = 0, nn = this.data.skins.length; ii < nn; ii++)\r\n                this.sortPathConstraintAttachment(this.data.skins[ii], slotIndex, slotBone);\r\n\r\n            let attachment = slot.getAttachment();\r\n            if (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\r\n\r\n            let constrained = constraint.bones;\r\n            let boneCount = constrained.length;\r\n            for (let ii = 0; ii < boneCount; ii++)\r\n                this.sortBone(constrained[ii]);\r\n\r\n            updateCache.push(constraint);\r\n\r\n            for (let ii = 0; ii < boneCount; ii++)\r\n                this.sortReset(constrained[ii].children);\r\n            for (let ii = 0; ii < boneCount; ii++)\r\n                constrained[ii].sorted = true;\r\n        }\r\n\r\n        let transformConstraints = this.transformConstraints;\r\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n            let constraint = transformConstraints[i];\r\n\r\n            this.sortBone(constraint.target);\r\n\r\n            let constrained = constraint.bones;\r\n            let boneCount = constrained.length;\r\n            for (let ii = 0; ii < boneCount; ii++)\r\n                this.sortBone(constrained[ii]);\r\n\r\n            updateCache.push(constraint);\r\n\r\n            for (let ii = 0; ii < boneCount; ii++)\r\n                this.sortReset(constrained[ii].children);\r\n            for (let ii = 0; ii < boneCount; ii++)\r\n                constrained[ii].sorted = true;\r\n        }\r\n\r\n        for (let i = 0, n = bones.length; i < n; i++)\r\n            this.sortBone(bones[i]);\r\n    }\r\n\r\n    sortPathConstraintAttachment (skin: Skin, slotIndex: number, slotBone: Bone) {\r\n        let attachments = skin.attachments[slotIndex];\r\n        if (!attachments) return;\r\n        for (let key in attachments) {\r\n            this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\r\n        }\r\n    }\r\n\r\n    sortPathConstraintAttachmentWith (attachment: Attachment, slotBone: Bone) {\r\n        if (!(attachment instanceof PathAttachment)) return;\r\n        let pathBones = (<PathAttachment>attachment).bones;\r\n        if (pathBones == null)\r\n            this.sortBone(slotBone);\r\n        else {\r\n            let bones = this.bones;\r\n            for (let i = 0; i < pathBones.length; i++) {\r\n                let boneIndex = pathBones[i];\r\n                this.sortBone(bones[boneIndex]);\r\n            }\r\n        }\r\n    }\r\n\r\n    sortBone (bone: Bone) {\r\n        if (bone.sorted) return;\r\n        let parent = bone.parent;\r\n        if (parent != null) this.sortBone(parent);\r\n        bone.sorted = true;\r\n        this._updateCache.push(bone);\r\n    }\r\n\r\n    sortReset (bones: Array<Bone>) {\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            if (bone.sorted) this.sortReset(bone.children);\r\n            bone.sorted = false;\r\n        }\r\n    }\r\n\r\n    /** Updates the world transform for each bone and applies constraints. */\r\n    updateWorldTransform () {\r\n        let updateCache = this._updateCache;\r\n        for (let i = 0, n = updateCache.length; i < n; i++)\r\n            updateCache[i].update();\r\n    }\r\n\r\n    /** Sets the bones, constraints, and slots to their setup pose values. */\r\n    setToSetupPose () {\r\n        this.setBonesToSetupPose();\r\n        this.setSlotsToSetupPose();\r\n    }\r\n\r\n    /** Sets the bones and constraints to their setup pose values. */\r\n    setBonesToSetupPose () {\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++)\r\n            bones[i].setToSetupPose();\r\n\r\n        let ikConstraints = this.ikConstraints;\r\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n            let constraint = ikConstraints[i];\r\n            constraint.bendDirection = constraint.data.bendDirection;\r\n            constraint.mix = constraint.data.mix;\r\n        }\r\n\r\n        let transformConstraints = this.transformConstraints;\r\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n            let constraint = transformConstraints[i];\r\n            let data = constraint.data;\r\n            constraint.rotateMix = data.rotateMix;\r\n            constraint.translateMix = data.translateMix;\r\n            constraint.scaleMix = data.scaleMix;\r\n            constraint.shearMix = data.shearMix;\r\n        }\r\n\r\n        let pathConstraints = this.pathConstraints;\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n            let constraint = pathConstraints[i];\r\n            let data = constraint.data;\r\n            constraint.position = data.position;\r\n            constraint.spacing = data.spacing;\r\n            constraint.rotateMix = data.rotateMix;\r\n            constraint.translateMix = data.translateMix;\r\n        }\r\n    }\r\n\r\n    setSlotsToSetupPose () {\r\n        let slots = this.slots;\r\n        Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\r\n        for (let i = 0, n = slots.length; i < n; i++)\r\n            slots[i].setToSetupPose();\r\n    }\r\n\r\n    /** @return May return null. */\r\n    getRootBone () {\r\n        if (this.bones.length == 0) return null;\r\n        return this.bones[0];\r\n    }\r\n\r\n    /** @return May be null. */\r\n    findBone (boneName: string) {\r\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            if (bone.data.name == boneName) return bone;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @return -1 if the bone was not found. */\r\n    findBoneIndex (boneName: string) {\r\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].data.name == boneName) return i;\r\n        return -1;\r\n    }\r\n\r\n    /** @return May be null. */\r\n    findSlot (slotName: string) {\r\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\r\n        let slots = this.slots;\r\n        for (let i = 0, n = slots.length; i < n; i++) {\r\n            let slot = slots[i];\r\n            if (slot.data.name == slotName) return slot;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @return -1 if the bone was not found. */\r\n    findSlotIndex (slotName: string) {\r\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\r\n        let slots = this.slots;\r\n        for (let i = 0, n = slots.length; i < n; i++)\r\n            if (slots[i].data.name == slotName) return i;\r\n        return -1;\r\n    }\r\n\r\n    /** Sets a skin by name.\r\n     * @see #setSkin(Skin) */\r\n    setSkinByName (skinName: string) {\r\n        let skin = this.data.findSkin(skinName);\r\n        if (skin == null) throw new Error(\"Skin not found: \" + skinName);\r\n        this.setSkin(skin);\r\n    }\r\n\r\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\r\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\r\n     * old skin, each slot's setup mode attachment is attached from the new skin.\r\n     * @param newSkin May be null. */\r\n    setSkin (newSkin: Skin) {\r\n        if (newSkin != null) {\r\n            if (this.skin != null)\r\n                newSkin.attachAll(this, this.skin);\r\n            else {\r\n                let slots = this.slots;\r\n                for (let i = 0, n = slots.length; i < n; i++) {\r\n                    let slot = slots[i];\r\n                    let name = slot.data.attachmentName;\r\n                    if (name != null) {\r\n                        let attachment: Attachment = newSkin.getAttachment(i, name);\r\n                        if (attachment != null) slot.setAttachment(attachment);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.skin = newSkin;\r\n    }\r\n\r\n    /** @return May be null. */\r\n    getAttachmentByName (slotName: string, attachmentName: string): Attachment {\r\n        return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\r\n    }\r\n\r\n    /** @return May be null. */\r\n    getAttachment (slotIndex: number, attachmentName: string): Attachment {\r\n        if (attachmentName == null) throw new Error(\"attachmentName cannot be null.\");\r\n        if (this.skin != null) {\r\n            let attachment: Attachment = this.skin.getAttachment(slotIndex, attachmentName);\r\n            if (attachment != null) return attachment;\r\n        }\r\n        if (this.data.defaultSkin != null) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\r\n        return null;\r\n    }\r\n\r\n    /** @param attachmentName May be null. */\r\n    setAttachment (slotName: string, attachmentName: string) {\r\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\r\n        let slots = this.slots;\r\n        for (let i = 0, n = slots.length; i < n; i++) {\r\n            let slot = slots[i];\r\n            if (slot.data.name == slotName) {\r\n                let attachment: Attachment = null;\r\n                if (attachmentName != null) {\r\n                    attachment = this.getAttachment(i, attachmentName);\r\n                    if (attachment == null)\r\n                        throw new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\r\n                }\r\n                slot.setAttachment(attachment);\r\n                return;\r\n            }\r\n        }\r\n        throw new Error(\"Slot not found: \" + slotName);\r\n    }\r\n\r\n    /** @return May be null. */\r\n    findIkConstraint (constraintName: string) {\r\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n        let ikConstraints = this.ikConstraints;\r\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n            let ikConstraint = ikConstraints[i];\r\n            if (ikConstraint.data.name == constraintName) return ikConstraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @return May be null. */\r\n    findTransformConstraint (constraintName: string) {\r\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n        let transformConstraints = this.transformConstraints;\r\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n            let constraint = transformConstraints[i];\r\n            if (constraint.data.name == constraintName) return constraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @return May be null. */\r\n    findPathConstraint (constraintName: string) {\r\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n        let pathConstraints = this.pathConstraints;\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n            let constraint = pathConstraints[i];\r\n            if (constraint.data.name == constraintName) return constraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\r\n     * @param offset The distance from the skeleton origin to the bottom left corner of the AABB.\r\n     * @param size The width and height of the AABB. */\r\n    getBounds (offset: Vector2, size: Vector2) {\r\n        if (offset == null) throw new Error(\"offset cannot be null.\");\r\n        if (size == null) throw new Error(\"size cannot be null.\");\r\n        let drawOrder = this.drawOrder;\r\n        let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\r\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\r\n            let slot = drawOrder[i];\r\n            let vertices: ArrayLike<number> = null;\r\n            let attachment = slot.getAttachment();\r\n            if (attachment instanceof RegionAttachment)\r\n                vertices = (<RegionAttachment>attachment).updateWorldVertices(slot, false);\r\n            else if (attachment instanceof MeshAttachment) //\r\n                vertices = (<MeshAttachment>attachment).updateWorldVertices(slot, true);\r\n            if (vertices != null) {\r\n                for (let ii = 0, nn = vertices.length; ii < nn; ii += 8) {\r\n                    let x = vertices[ii], y = vertices[ii + 1];\r\n                    minX = Math.min(minX, x);\r\n                    minY = Math.min(minY, y);\r\n                    maxX = Math.max(maxX, x);\r\n                    maxY = Math.max(maxY, y);\r\n                }\r\n            }\r\n        }\r\n        offset.set(minX, minY);\r\n        size.set(maxX - minX, maxY - minY);\r\n    }\r\n\r\n    update (delta: number) {\r\n        this.time += delta;\r\n    }\r\n}\r\n","import {Utils, Pool} from \"./Utils\";\r\nimport {Skeleton} from \"./Skeleton\";\r\nimport {BoundingBoxAttachment} from \"./attachments\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class SkeletonBounds {\r\n    minX = 0; minY = 0; maxX = 0; maxY = 0;\r\n    boundingBoxes = new Array<BoundingBoxAttachment>();\r\n    polygons = new Array<ArrayLike<number>>();\r\n    private polygonPool = new Pool<ArrayLike<number>>(() => {\r\n        return Utils.newFloatArray(16);\r\n    });\r\n\r\n    update (skeleton: Skeleton, updateAabb: boolean) {\r\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n        let boundingBoxes = this.boundingBoxes;\r\n        let polygons = this.polygons;\r\n        let polygonPool = this.polygonPool;\r\n        let slots = skeleton.slots;\r\n        let slotCount = slots.length;\r\n\r\n        boundingBoxes.length = 0;\r\n        polygonPool.freeAll(polygons);\r\n        polygons.length = 0;\r\n\r\n        for (let i = 0; i < slotCount; i++) {\r\n            let slot = slots[i];\r\n            let attachment = slot.getAttachment();\r\n            if (attachment instanceof BoundingBoxAttachment) {\r\n                let boundingBox = attachment as BoundingBoxAttachment;\r\n                boundingBoxes.push(boundingBox);\r\n\r\n                let polygon = polygonPool.obtain();\r\n                if (polygon.length != boundingBox.worldVerticesLength) {\r\n                    polygon = Utils.newFloatArray(boundingBox.worldVerticesLength);\r\n                }\r\n                polygons.push(polygon);\r\n                boundingBox.computeWorldVertices(slot, polygon);\r\n            }\r\n        }\r\n\r\n        if (updateAabb) this.aabbCompute();\r\n    }\r\n\r\n    aabbCompute () {\r\n        let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\r\n        let polygons = this.polygons;\r\n        for (let i = 0, n = polygons.length; i < n; i++) {\r\n            let polygon = polygons[i];\r\n            let vertices = polygon;\r\n            for (let ii = 0, nn = polygon.length; ii < nn; ii += 2) {\r\n                let x = vertices[ii];\r\n                let y = vertices[ii + 1];\r\n                minX = Math.min(minX, x);\r\n                minY = Math.min(minY, y);\r\n                maxX = Math.max(maxX, x);\r\n                maxY = Math.max(maxY, y);\r\n            }\r\n        }\r\n        this.minX = minX;\r\n        this.minY = minY;\r\n        this.maxX = maxX;\r\n        this.maxY = maxY;\r\n    }\r\n\r\n    /** Returns true if the axis aligned bounding box contains the point. */\r\n    aabbContainsPoint (x: number, y: number) {\r\n        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\r\n    }\r\n\r\n    /** Returns true if the axis aligned bounding box intersects the line segment. */\r\n    aabbIntersectsSegment (x1: number, y1: number, x2: number, y2: number) {\r\n        let minX = this.minX;\r\n        let minY = this.minY;\r\n        let maxX = this.maxX;\r\n        let maxY = this.maxY;\r\n        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\r\n            return false;\r\n        let m = (y2 - y1) / (x2 - x1);\r\n        let y = m * (minX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        y = m * (maxX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        let x = (minY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        x = (maxY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        return false;\r\n    }\r\n\r\n    /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\r\n    aabbIntersectsSkeleton (bounds: SkeletonBounds) {\r\n        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\r\n    }\r\n\r\n    /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\r\n     * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */\r\n    containsPoint (x: number, y: number): BoundingBoxAttachment {\r\n        let polygons = this.polygons;\r\n        for (let i = 0, n = polygons.length; i < n; i++)\r\n            if (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];\r\n        return null;\r\n    }\r\n\r\n    /** Returns true if the polygon contains the point. */\r\n    containsPointPolygon (polygon: ArrayLike<number>, x: number, y: number) {\r\n        let vertices = polygon;\r\n        let nn = polygon.length;\r\n\r\n        let prevIndex = nn - 2;\r\n        let inside = false;\r\n        for (let ii = 0; ii < nn; ii += 2) {\r\n            let vertexY = vertices[ii + 1];\r\n            let prevY = vertices[prevIndex + 1];\r\n            if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {\r\n                let vertexX = vertices[ii];\r\n                if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x) inside = !inside;\r\n            }\r\n            prevIndex = ii;\r\n        }\r\n        return inside;\r\n    }\r\n\r\n    /** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it\r\n     * is usually more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns\r\n     * true. */\r\n    intersectsSegment (x1: number, y1: number, x2: number, y2: number) {\r\n        let polygons = this.polygons;\r\n        for (let i = 0, n = polygons.length; i < n; i++)\r\n            if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];\r\n        return null;\r\n    }\r\n\r\n    /** Returns true if the polygon contains any part of the line segment. */\r\n    intersectsSegmentPolygon (polygon: ArrayLike<number>, x1: number, y1: number, x2: number, y2: number) {\r\n        let vertices = polygon;\r\n        let nn = polygon.length;\r\n\r\n        let width12 = x1 - x2, height12 = y1 - y2;\r\n        let det1 = x1 * y2 - y1 * x2;\r\n        let x3 = vertices[nn - 2], y3 = vertices[nn - 1];\r\n        for (let ii = 0; ii < nn; ii += 2) {\r\n            let x4 = vertices[ii], y4 = vertices[ii + 1];\r\n            let det2 = x3 * y4 - y3 * x4;\r\n            let width34 = x3 - x4, height34 = y3 - y4;\r\n            let det3 = width12 * height34 - height12 * width34;\r\n            let x = (det1 * width34 - width12 * det2) / det3;\r\n            if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {\r\n                let y = (det1 * height34 - height12 * det2) / det3;\r\n                if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\r\n            }\r\n            x3 = x4;\r\n            y3 = y4;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** Returns the polygon for the specified bounding box, or null. */\r\n    getPolygon (boundingBox: BoundingBoxAttachment) {\r\n        if (boundingBox == null) throw new Error(\"boundingBox cannot be null.\");\r\n        let index = this.boundingBoxes.indexOf(boundingBox);\r\n        return index == -1 ? null : this.polygons[index];\r\n    }\r\n\r\n    getWidth () {\r\n        return this.maxX - this.minX;\r\n    }\r\n\r\n    getHeight () {\r\n        return this.maxY - this.minY;\r\n    }\r\n}\r\n","import {BoneData} from \"./BoneData\";\r\nimport {SlotData} from \"./SlotData\";\r\nimport {Skin} from \"./Skin\";\r\nimport {EventData} from \"./EventData\";\r\nimport {Animation} from \"./Animation\";\r\nimport {IkConstraintData} from \"./IkConstraintData\";\r\nimport {TransformConstraintData} from \"./TransformConstraintData\";\r\nimport {PathConstraintData} from \"./PathConstraintData\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class SkeletonData {\r\n    name: string;\r\n    bones = new Array<BoneData>(); // Ordered parents first.\r\n    slots = new Array<SlotData>(); // Setup pose draw order.\r\n    skins = new Array<Skin>();\r\n    defaultSkin: Skin;\r\n    events = new Array<EventData>();\r\n    animations = new Array<Animation>();\r\n    ikConstraints = new Array<IkConstraintData>();\r\n    transformConstraints = new Array<TransformConstraintData>();\r\n    pathConstraints = new Array<PathConstraintData>();\r\n    width: number; height: number;\r\n    version: string; hash: string; imagesPath: string;\r\n\r\n    findBone (boneName: string) {\r\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            if (bone.name == boneName) return bone;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findBoneIndex (boneName: string) {\r\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].name == boneName) return i;\r\n        return -1;\r\n    }\r\n\r\n    findSlot (slotName: string) {\r\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\r\n        let slots = this.slots;\r\n        for (let i = 0, n = slots.length; i < n; i++) {\r\n            let slot = slots[i];\r\n            if (slot.name == slotName) return slot;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findSlotIndex (slotName: string) {\r\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\r\n        let slots = this.slots;\r\n        for (let i = 0, n = slots.length; i < n; i++)\r\n            if (slots[i].name == slotName) return i;\r\n        return -1;\r\n    }\r\n\r\n    findSkin (skinName: string) {\r\n        if (skinName == null) throw new Error(\"skinName cannot be null.\");\r\n        let skins = this.skins;\r\n        for (let i = 0, n = skins.length; i < n; i++) {\r\n            let skin = skins[i];\r\n            if (skin.name == skinName) return skin;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findEvent (eventDataName: string) {\r\n        if (eventDataName == null) throw new Error(\"eventDataName cannot be null.\");\r\n        let events = this.events;\r\n        for (let i = 0, n = events.length; i < n; i++) {\r\n            let event = events[i];\r\n            if (event.name == eventDataName) return event;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findAnimation (animationName: string) {\r\n        if (animationName == null) throw new Error(\"animationName cannot be null.\");\r\n        let animations = this.animations;\r\n        for (let i = 0, n = animations.length; i < n; i++) {\r\n            let animation = animations[i];\r\n            if (animation.name == animationName) return animation;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findIkConstraint (constraintName: string) {\r\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n        let ikConstraints = this.ikConstraints;\r\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n            let constraint = ikConstraints[i];\r\n            if (constraint.name == constraintName) return constraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findTransformConstraint (constraintName: string) {\r\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n        let transformConstraints = this.transformConstraints;\r\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n            let constraint = transformConstraints[i];\r\n            if (constraint.name == constraintName) return constraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findPathConstraint (constraintName: string) {\r\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n        let pathConstraints = this.pathConstraints;\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n            let constraint = pathConstraints[i];\r\n            if (constraint.name == constraintName) return constraint;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    findPathConstraintIndex (pathConstraintName: string) {\r\n        if (pathConstraintName == null) throw new Error(\"pathConstraintName cannot be null.\");\r\n        let pathConstraints = this.pathConstraints;\r\n        for (let i = 0, n = pathConstraints.length; i < n; i++)\r\n            if (pathConstraints[i].name == pathConstraintName) return i;\r\n        return -1;\r\n    }\r\n}\r\n","import {SkeletonData} from \"./SkeletonData\";\r\nimport {BoneData} from \"./BoneData\";\r\nimport {SlotData} from \"./SlotData\";\r\nimport {Event} from \"./Event\";\r\nimport {IkConstraintData} from \"./IkConstraintData\";\r\nimport {TransformConstraintData} from \"./TransformConstraintData\";\r\nimport {PathConstraintData, PositionMode, SpacingMode, RotateMode} from \"./PathConstraintData\";\r\nimport {Skin} from \"./Skin\";\r\nimport {EventData} from \"./EventData\";\r\nimport {Attachment, AttachmentLoader, MeshAttachment, VertexAttachment} from \"./attachments\";\r\nimport {Utils, Color} from \"./Utils\";\r\nimport {\r\n    Timeline, ColorTimeline, AttachmentTimeline, RotateTimeline, TranslateTimeline,\r\n    ScaleTimeline, ShearTimeline, IkConstraintTimeline, TransformConstraintTimeline, PathConstraintPositionTimeline,\r\n    PathConstraintSpacingTimeline, PathConstraintMixTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline,\r\n    Animation, CurveTimeline\r\n} from \"./Animation\";\r\nimport {BlendMode} from \"./BlendMode\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class SkeletonJson {\r\n    attachmentLoader: AttachmentLoader;\r\n    scale = 1;\r\n    private linkedMeshes = new Array<LinkedMesh>();\r\n\r\n    constructor (attachmentLoader: AttachmentLoader) {\r\n        this.attachmentLoader = attachmentLoader;\r\n    }\r\n\r\n    readSkeletonData (json: string | any ): SkeletonData {\r\n        let scale = this.scale;\r\n        let skeletonData = new SkeletonData();\r\n        let root = typeof(json) === \"string\" ? JSON.parse(json) : json;\r\n\r\n        // Skeleton\r\n        let skeletonMap = root.skeleton;\r\n        if (skeletonMap != null) {\r\n            skeletonData.hash = skeletonMap.hash;\r\n            skeletonData.version = skeletonMap.spine;\r\n            skeletonData.width = skeletonMap.width;\r\n            skeletonData.height = skeletonMap.height;\r\n            skeletonData.imagesPath = skeletonMap.images;\r\n        }\r\n\r\n        // Bones\r\n        if (root.bones) {\r\n            for (let i = 0; i < root.bones.length; i++) {\r\n                let boneMap = root.bones[i];\r\n\r\n                let parent: BoneData = null;\r\n                let parentName: string = this.getValue(boneMap, \"parent\", null);\r\n                if (parentName != null) {\r\n                    parent = skeletonData.findBone(parentName);\r\n                    if (parent == null) throw new Error(\"Parent bone not found: \" + parentName);\r\n                }\r\n                let data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\r\n                data.length = this.getValue(boneMap, \"length\", 0) * scale;\r\n                data.x = this.getValue(boneMap, \"x\", 0) * scale;\r\n                data.y = this.getValue(boneMap, \"y\", 0) * scale;\r\n                data.rotation = this.getValue(boneMap, \"rotation\", 0);\r\n                data.scaleX = this.getValue(boneMap, \"scaleX\", 1);\r\n                data.scaleY = this.getValue(boneMap, \"scaleY\", 1);\r\n                data.shearX = this.getValue(boneMap, \"shearX\", 0);\r\n                data.shearY = this.getValue(boneMap, \"shearY\", 0);\r\n                data.inheritRotation = this.getValue(boneMap, \"inheritRotation\", true);\r\n                data.inheritScale = this.getValue(boneMap, \"inheritScale\", true);\r\n\r\n                skeletonData.bones.push(data);\r\n            }\r\n        }\r\n\r\n        // Slots.\r\n        if (root.slots) {\r\n            for (let i = 0; i < root.slots.length; i++) {\r\n                let slotMap = root.slots[i];\r\n                let slotName: string = slotMap.name;\r\n                let boneName: string = slotMap.bone;\r\n                let boneData = skeletonData.findBone(boneName);\r\n                if (boneData == null) throw new Error(\"Slot bone not found: \" + boneName);\r\n                let data = new SlotData(skeletonData.slots.length, slotName, boneData);\r\n\r\n                let color: string = this.getValue(slotMap, \"color\", null);\r\n                if (color != null) data.color.setFromString(color);\r\n\r\n                data.attachmentName = this.getValue(slotMap, \"attachment\", null);\r\n                data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, \"blend\", \"normal\"));\r\n                skeletonData.slots.push(data);\r\n            }\r\n        }\r\n\r\n        // IK constraints\r\n        if (root.ik) {\r\n            for (let i = 0; i < root.ik.length; i++) {\r\n                let constraintMap = root.ik[i];\r\n                let data = new IkConstraintData(constraintMap.name);\r\n\r\n                for (let j = 0; j < constraintMap.bones.length; j++) {\r\n                    let boneName = constraintMap.bones[j];\r\n                    let bone = skeletonData.findBone(boneName);\r\n                    if (bone == null) throw new Error(\"IK bone not found: \" + boneName);\r\n                    data.bones.push(bone);\r\n                }\r\n\r\n                let targetName: string = constraintMap.target;\r\n                data.target = skeletonData.findBone(targetName);\r\n                if (data.target == null) throw new Error(\"IK target bone not found: \" + targetName);\r\n\r\n                data.bendDirection = this.getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\r\n                data.mix = this.getValue(constraintMap, \"mix\", 1);\r\n\r\n                skeletonData.ikConstraints.push(data);\r\n            }\r\n        }\r\n\r\n        // Transform constraints.\r\n        if (root.transform) {\r\n            for (let i = 0; i < root.transform.length; i++) {\r\n                let constraintMap = root.transform[i];\r\n                let data = new TransformConstraintData(constraintMap.name);\r\n\r\n                for (let j = 0; j < constraintMap.bones.length; j++) {\r\n                    let boneName = constraintMap.bones[j];\r\n                    let bone = skeletonData.findBone(boneName);\r\n                    if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\r\n                    data.bones.push(bone);\r\n                }\r\n\r\n                let targetName: string = constraintMap.target;\r\n                data.target = skeletonData.findBone(targetName);\r\n                if (data.target == null) throw new Error(\"Transform constraint target bone not found: \" + targetName);\r\n\r\n                data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\r\n                data.offsetX = this.getValue(constraintMap, \"x\", 0) * scale;\r\n                data.offsetY = this.getValue(constraintMap, \"y\", 0) * scale;\r\n                data.offsetScaleX = this.getValue(constraintMap, \"scaleX\", 0);\r\n                data.offsetScaleY = this.getValue(constraintMap, \"scaleY\", 0);\r\n                data.offsetShearY = this.getValue(constraintMap, \"shearY\", 0);\r\n\r\n                data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\r\n                data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\r\n                data.scaleMix = this.getValue(constraintMap, \"scaleMix\", 1);\r\n                data.shearMix = this.getValue(constraintMap, \"shearMix\", 1);\r\n\r\n                skeletonData.transformConstraints.push(data);\r\n            }\r\n        }\r\n\r\n        // Path constraints.\r\n        if (root.path) {\r\n            for (let i = 0; i < root.path.length; i++) {\r\n                let constraintMap = root.path[i];\r\n                let data = new PathConstraintData(constraintMap.name);\r\n\r\n                for (let j = 0; j < constraintMap.bones.length; j++) {\r\n                    let boneName = constraintMap.bones[j];\r\n                    let bone = skeletonData.findBone(boneName);\r\n                    if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\r\n                    data.bones.push(bone);\r\n                }\r\n\r\n                let targetName: string = constraintMap.target;\r\n                data.target = skeletonData.findSlot(targetName);\r\n                if (data.target == null) throw new Error(\"Path target slot not found: \" + targetName);\r\n\r\n                data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, \"positionMode\", \"percent\"));\r\n                data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, \"spacingMode\", \"length\"));\r\n                data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, \"rotateMode\", \"tangent\"));\r\n                data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\r\n                data.position = this.getValue(constraintMap, \"position\", 0);\r\n                if (data.positionMode == PositionMode.Fixed) data.position *= scale;\r\n                data.spacing = this.getValue(constraintMap, \"spacing\", 0);\r\n                if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\r\n                data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\r\n                data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\r\n\r\n                skeletonData.pathConstraints.push(data);\r\n            }\r\n        }\r\n\r\n        // Skins.\r\n        if (root.skins) {\r\n            for (let skinName in root.skins) {\r\n                let skinMap = root.skins[skinName]\r\n                let skin = new Skin(skinName);\r\n                for (let slotName in skinMap) {\r\n                    let slotIndex = skeletonData.findSlotIndex(slotName);\r\n                    if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotName);\r\n                    let slotMap = skinMap[slotName];\r\n                    for (let entryName in slotMap) {\r\n                        let attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName);\r\n                        if (attachment != null) skin.addAttachment(slotIndex, entryName, attachment);\r\n                    }\r\n                }\r\n                skeletonData.skins.push(skin);\r\n                if (skin.name == \"default\") skeletonData.defaultSkin = skin;\r\n            }\r\n        }\r\n\r\n        // Linked meshes.\r\n        for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\r\n            let linkedMesh = this.linkedMeshes[i];\r\n            let skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n            if (skin == null) throw new Error(\"Skin not found: \" + linkedMesh.skin);\r\n            let parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n            if (parent == null) throw new Error(\"Parent mesh not found: \" + linkedMesh.parent);\r\n            linkedMesh.mesh.setParentMesh(<MeshAttachment> parent);\r\n            // linkedMesh.mesh.updateUVs();\r\n        }\r\n        this.linkedMeshes.length = 0;\r\n\r\n        // Events.\r\n        if (root.events) {\r\n            for (let eventName in root.events) {\r\n                let eventMap = root.events[eventName];\r\n                let data = new EventData(eventName);\r\n                data.intValue = this.getValue(eventMap, \"int\", 0);\r\n                data.floatValue = this.getValue(eventMap, \"float\", 0);\r\n                data.stringValue = this.getValue(eventMap, \"string\", null);\r\n                skeletonData.events.push(data);\r\n            }\r\n        }\r\n\r\n        // Animations.\r\n        if (root.animations) {\r\n            for (let animationName in root.animations) {\r\n                let animationMap = root.animations[animationName];\r\n                this.readAnimation(animationMap, animationName, skeletonData);\r\n            }\r\n        }\r\n\r\n        return skeletonData;\r\n    }\r\n\r\n    readAttachment (map: any, skin: Skin, slotIndex: number, name: string): Attachment {\r\n        let scale = this.scale;\r\n        name = this.getValue(map, \"name\", name);\r\n\r\n        let type = this.getValue(map, \"type\", \"region\");\r\n\r\n        switch (type) {\r\n            case \"region\": {\r\n                let path = this.getValue(map, \"path\", name);\r\n                let region = this.attachmentLoader.newRegionAttachment(skin, name, path);\r\n                if (region == null) return null;\r\n                region.path = path;\r\n                region.x = this.getValue(map, \"x\", 0) * scale;\r\n                region.y = this.getValue(map, \"y\", 0) * scale;\r\n                region.scaleX = this.getValue(map, \"scaleX\", 1);\r\n                region.scaleY = this.getValue(map, \"scaleY\", 1);\r\n                region.rotation = this.getValue(map, \"rotation\", 0);\r\n                region.width = map.width * scale;\r\n                region.height = map.height * scale;\r\n\r\n                let color: string = this.getValue(map, \"color\", null);\r\n                if (color != null) region.color.setFromString(color);\r\n\r\n                return region;\r\n            }\r\n            case \"boundingbox\": {\r\n                let box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n                if (box == null) return null;\r\n                this.readVertices(map, box, map.vertexCount << 1);\r\n                let color: string = this.getValue(map, \"color\", null);\r\n                if (color != null) box.color.setFromString(color);\r\n                return box;\r\n            }\r\n            //weightedmesh is deprecated but who cares\r\n            case \"weightedmesh\":\r\n            case \"skinnedmesh\":\r\n            case \"mesh\":\r\n            case \"linkedmesh\": {\r\n                let path = this.getValue(map, \"path\", name);\r\n                let mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n                if (mesh == null) return null;\r\n                mesh.path = path;\r\n\r\n                let color = this.getValue(map, \"color\", null);\r\n                if (color != null) mesh.color.setFromString(color);\r\n\r\n                let parent: string = this.getValue(map, \"parent\", null);\r\n                if (parent != null) {\r\n                    mesh.inheritDeform = this.getValue(map, \"deform\", true);\r\n                    this.linkedMeshes.push(new LinkedMesh(mesh, <string> this.getValue(map, \"skin\", null), slotIndex, parent));\r\n                    return mesh;\r\n                }\r\n\r\n                let uvs: Array<number> = map.uvs;\r\n                this.readVertices(map, mesh, uvs.length);\r\n                mesh.triangles = map.triangles;\r\n                mesh.regionUVs = uvs;\r\n                // mesh.updateUVs();\r\n\r\n                mesh.hullLength = this.getValue(map, \"hull\", 0) * 2;\r\n                return mesh;\r\n            }\r\n            case \"path\": {\r\n                let path = this.attachmentLoader.newPathAttachment(skin, name);\r\n                if (path == null) return null;\r\n                path.closed = this.getValue(map, \"closed\", false);\r\n                path.constantSpeed = this.getValue(map, \"constantSpeed\", true);\r\n\r\n                let vertexCount = map.vertexCount;\r\n                this.readVertices(map, path, vertexCount << 1);\r\n\r\n                let lengths: Array<number> = Utils.newArray(vertexCount / 3, 0);\r\n                for (let i = 0; i < map.lengths.length; i++)\r\n                    lengths[i++] = map.lengths[i] * scale;\r\n                path.lengths = lengths;\r\n\r\n                let color: string = this.getValue(map, \"color\", null);\r\n                if (color != null) path.color.setFromString(color);\r\n                return path;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    readVertices (map: any, attachment: VertexAttachment, verticesLength: number) {\r\n        let scale = this.scale;\r\n        attachment.worldVerticesLength = verticesLength;\r\n        let vertices: Array<number> = map.vertices;\r\n        if (verticesLength == vertices.length) {\r\n            if (scale != 1) {\r\n                for (let i = 0, n = vertices.length; i < n; i++)\r\n                    vertices[i] *= scale;\r\n            }\r\n            attachment.vertices = Utils.toFloatArray(vertices);\r\n            return;\r\n        }\r\n        let weights = new Array<number>();\r\n        let bones = new Array<number>();\r\n        for (let i = 0, n = vertices.length; i < n;) {\r\n            let boneCount = vertices[i++];\r\n            bones.push(boneCount);\r\n            for (let nn = i + boneCount * 4; i < nn; i += 4) {\r\n                bones.push(vertices[i]);\r\n                weights.push(vertices[i + 1] * scale);\r\n                weights.push(vertices[i + 2] * scale);\r\n                weights.push(vertices[i + 3]);\r\n            }\r\n        }\r\n        attachment.bones = bones;\r\n        attachment.vertices = Utils.toFloatArray(weights);\r\n    }\r\n\r\n    readAnimation (map: any, name: string, skeletonData: SkeletonData) {\r\n        let scale = this.scale;\r\n        let timelines = new Array<Timeline>();\r\n        let duration = 0;\r\n\r\n        // Slot timelines.\r\n        if (map.slots) {\r\n            for (let slotName in map.slots) {\r\n                let slotMap = map.slots[slotName];\r\n                let slotIndex = skeletonData.findSlotIndex(slotName);\r\n                if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotName);\r\n                for (let timelineName in slotMap) {\r\n                    let timelineMap = slotMap[timelineName];\r\n                    if (timelineName == \"color\") {\r\n                        let timeline = new ColorTimeline(timelineMap.length);\r\n                        timeline.slotIndex = slotIndex;\r\n\r\n                        let frameIndex = 0;\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            let valueMap = timelineMap[i];\r\n                            let color = new Color();\r\n                            color.setFromString(valueMap.color);\r\n                            timeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * ColorTimeline.ENTRIES]);\r\n\r\n                    } else if (timelineName = \"attachment\") {\r\n                        let timeline = new AttachmentTimeline(timelineMap.length);\r\n                        timeline.slotIndex = slotIndex;\r\n\r\n                        let frameIndex = 0;\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            let valueMap = timelineMap[i];\r\n                            timeline.setFrame(frameIndex++, valueMap.time, valueMap.name);\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n                    } else\r\n                        throw new Error(\"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\");\r\n                }\r\n            }\r\n        }\r\n\r\n        // Bone timelines.\r\n        if (map.bones) {\r\n            for (let boneName in map.bones) {\r\n                let boneMap = map.bones[boneName];\r\n                let boneIndex = skeletonData.findBoneIndex(boneName);\r\n                if (boneIndex == -1) throw new Error(\"Bone not found: \" + boneName);\r\n                for (let timelineName in boneMap) {\r\n                    let timelineMap = boneMap[timelineName];\r\n                    if (timelineName === \"rotate\") {\r\n                        let timeline = new RotateTimeline(timelineMap.length);\r\n                        timeline.boneIndex = boneIndex;\r\n\r\n                        let frameIndex = 0;\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            let valueMap = timelineMap[i];\r\n                            timeline.setFrame(frameIndex, valueMap.time, valueMap.angle);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * RotateTimeline.ENTRIES]);\r\n\r\n                    } else if (timelineName === \"translate\" || timelineName === \"scale\" || timelineName === \"shear\") {\r\n                        let timeline: TranslateTimeline = null;\r\n                        let timelineScale = 1;\r\n                        if (timelineName === \"scale\")\r\n                            timeline = new ScaleTimeline(timelineMap.length);\r\n                        else if (timelineName === \"shear\")\r\n                            timeline = new ShearTimeline(timelineMap.length);\r\n                        else {\r\n                            timeline = new TranslateTimeline(timelineMap.length);\r\n                            timelineScale = scale;\r\n                        }\r\n                        timeline.boneIndex = boneIndex;\r\n\r\n                        let frameIndex = 0;\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            let valueMap = timelineMap[i];\r\n                            let x = this.getValue(valueMap, \"x\", 0), y = this.getValue(valueMap, \"y\", 0);\r\n                            timeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TranslateTimeline.ENTRIES]);\r\n\r\n                    } else\r\n                        throw new Error(\"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\");\r\n                }\r\n            }\r\n        }\r\n\r\n        // IK constraint timelines.\r\n        if (map.ik) {\r\n            for (let constraintName in map.ik) {\r\n                let constraintMap = map.ik[constraintName];\r\n                let constraint = skeletonData.findIkConstraint(constraintName);\r\n                let timeline = new IkConstraintTimeline(constraintMap.length);\r\n                timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\r\n                let frameIndex = 0;\r\n                for (let i = 0; i < constraintMap.length; i++) {\r\n                    let valueMap = constraintMap[i];\r\n                    timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"mix\", 1),\r\n                        this.getValue(valueMap, \"bendPositive\", true) ? 1 : -1);\r\n                    this.readCurve(valueMap, timeline, frameIndex);\r\n                    frameIndex++;\r\n                }\r\n                timelines.push(timeline);\r\n                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * IkConstraintTimeline.ENTRIES]);\r\n            }\r\n        }\r\n\r\n        // Transform constraint timelines.\r\n        if (map.transform) {\r\n            for (let constraintName in map.transform) {\r\n                let constraintMap = map.transform[constraintName];\r\n                let constraint = skeletonData.findTransformConstraint(constraintName);\r\n                let timeline = new TransformConstraintTimeline(constraintMap.length);\r\n                timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\r\n                let frameIndex = 0;\r\n                for (let i = 0; i < constraintMap.length; i++) {\r\n                    let valueMap = constraintMap[i];\r\n                    timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1),\r\n                        this.getValue(valueMap, \"translateMix\", 1), this.getValue(valueMap, \"scaleMix\", 1), this.getValue(valueMap, \"shearMix\", 1));\r\n                    this.readCurve(valueMap, timeline, frameIndex);\r\n                    frameIndex++;\r\n                }\r\n                timelines.push(timeline);\r\n                duration = Math.max(duration,\r\n                    timeline.frames[(timeline.getFrameCount() - 1) * TransformConstraintTimeline.ENTRIES]);\r\n            }\r\n        }\r\n\r\n        // Path constraint timelines.\r\n        if (map.paths) {\r\n            for (let constraintName in map.paths) {\r\n                let constraintMap = map.paths[constraintName];\r\n                let index = skeletonData.findPathConstraintIndex(constraintName);\r\n                if (index == -1) throw new Error(\"Path constraint not found: \" + constraintName);\r\n                let data = skeletonData.pathConstraints[index];\r\n                for (let timelineName in constraintMap) {\r\n                    let timelineMap = constraintMap[timelineName];\r\n                    if (timelineName === \"position\" || timelineName === \"spacing\") {\r\n                        let timeline: PathConstraintPositionTimeline = null;\r\n                        let timelineScale = 1;\r\n                        if (timelineName === \"spacing\") {\r\n                            timeline = new PathConstraintSpacingTimeline(timelineMap.length);\r\n                            if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) timelineScale = scale;\r\n                        } else {\r\n                            timeline = new PathConstraintPositionTimeline(timelineMap.length);\r\n                            if (data.positionMode == PositionMode.Fixed) timelineScale = scale;\r\n                        }\r\n                        timeline.pathConstraintIndex = index;\r\n                        let frameIndex = 0;\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            let valueMap = timelineMap[i];\r\n                            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration,\r\n                            timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintPositionTimeline.ENTRIES]);\r\n                    } else if (timelineName === \"mix\") {\r\n                        let timeline = new PathConstraintMixTimeline(timelineMap.length);\r\n                        timeline.pathConstraintIndex = index;\r\n                        let frameIndex = 0;\r\n                        for (let i = 0; i < timelineMap.length; i++) {\r\n                            let valueMap = timelineMap[i];\r\n                            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1),\r\n                                this.getValue(valueMap, \"translateMix\", 1));\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration,\r\n                            timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintMixTimeline.ENTRIES]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Deform timelines.\r\n        if (map.deform) {\r\n            for (let deformName in map.deform) {\r\n                let deformMap = map.deform[deformName];\r\n                let skin = skeletonData.findSkin(deformName);\r\n                if (skin == null) throw new Error(\"Skin not found: \" + deformName);\r\n                for (let slotName in deformMap) {\r\n                    let slotMap = deformMap[slotName];\r\n                    let slotIndex = skeletonData.findSlotIndex(slotName);\r\n                    if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotMap.name);\r\n                    for (let timelineName in slotMap) {\r\n                        let timelineMap = slotMap[timelineName];\r\n                        let attachment = <VertexAttachment>skin.getAttachment(slotIndex, timelineName);\r\n                        if (attachment == null) throw new Error(\"Deform attachment not found: \" + timelineMap.name);\r\n                        let weighted = attachment.bones != null;\r\n                        let vertices = attachment.vertices;\r\n                        let deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\r\n\r\n                        let timeline = new DeformTimeline(timelineMap.length);\r\n                        timeline.slotIndex = slotIndex;\r\n                        timeline.attachment = attachment;\r\n\r\n                        let frameIndex = 0;\r\n                        for (let j = 0; j < timelineMap.length; j++) {\r\n                            let valueMap = timelineMap[j];\r\n                            let deform: ArrayLike<number>;\r\n                            let verticesValue: Array<Number> = this.getValue(valueMap, \"vertices\", null);\r\n                            if (verticesValue == null)\r\n                                deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\r\n                            else {\r\n                                deform = Utils.newFloatArray(deformLength);\r\n                                let start = <number>this.getValue(valueMap, \"offset\", 0);\r\n                                Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\r\n                                if (scale != 1) {\r\n                                    for (let i = start, n = i + verticesValue.length; i < n; i++)\r\n                                        deform[i] *= scale;\r\n                                }\r\n                                if (!weighted) {\r\n                                    for (let i = 0; i < deformLength; i++)\r\n                                        deform[i] += vertices[i];\r\n                                }\r\n                            }\r\n\r\n                            timeline.setFrame(frameIndex, valueMap.time, deform);\r\n                            this.readCurve(valueMap, timeline, frameIndex);\r\n                            frameIndex++;\r\n                        }\r\n                        timelines.push(timeline);\r\n                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Draw order timeline.\r\n        let drawOrderNode = map.drawOrder;\r\n        if (drawOrderNode == null) drawOrderNode = map.draworder;\r\n        if (drawOrderNode != null) {\r\n            let timeline = new DrawOrderTimeline(drawOrderNode.length);\r\n            let slotCount = skeletonData.slots.length;\r\n            let frameIndex = 0;\r\n            for (let j = 0; j < drawOrderNode.length; j++) {\r\n                let drawOrderMap = drawOrderNode[j];\r\n                let drawOrder: Array<number> = null;\r\n                let offsets = this.getValue(drawOrderMap, \"offsets\", null);\r\n                if (offsets != null) {\r\n                    drawOrder = Utils.newArray<number>(slotCount, -1);\r\n                    let unchanged = Utils.newArray<number>(slotCount - offsets.length, 0);\r\n                    let originalIndex = 0, unchangedIndex = 0;\r\n                    for (let i = 0; i < offsets.length; i++) {\r\n                        let offsetMap = offsets[i];\r\n                        let slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\r\n                        if (slotIndex == -1) throw new Error(\"Slot not found: \" + offsetMap.slot);\r\n                        // Collect unchanged items.\r\n                        while (originalIndex != slotIndex)\r\n                            unchanged[unchangedIndex++] = originalIndex++;\r\n                        // Set changed items.\r\n                        drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\r\n                    }\r\n                    // Collect remaining unchanged items.\r\n                    while (originalIndex < slotCount)\r\n                        unchanged[unchangedIndex++] = originalIndex++;\r\n                    // Fill in unchanged items.\r\n                    for (let i = slotCount - 1; i >= 0; i--)\r\n                        if (drawOrder[i] == -1) drawOrder[i] = unchanged[--unchangedIndex];\r\n                }\r\n                timeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n        }\r\n\r\n        // Event timeline.\r\n        if (map.events) {\r\n            let timeline = new EventTimeline(map.events.length);\r\n            let frameIndex = 0;\r\n            for (let i = 0; i < map.events.length; i++) {\r\n                let eventMap = map.events[i];\r\n                let eventData = skeletonData.findEvent(eventMap.name);\r\n                if (eventData == null) throw new Error(\"Event not found: \" + eventMap.name);\r\n                let event = new Event(eventMap.time, eventData);\r\n                event.intValue = this.getValue(eventMap, \"int\", eventData.intValue);\r\n                event.floatValue = this.getValue(eventMap, \"float\", eventData.floatValue);\r\n                event.stringValue = this.getValue(eventMap, \"string\", eventData.stringValue);\r\n                timeline.setFrame(frameIndex++, event);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n        }\r\n\r\n        if (isNaN(duration)) {\r\n            throw new Error(\"Error while parsing animation, duration is NaN\");\r\n        }\r\n\r\n        skeletonData.animations.push(new Animation(name, timelines, duration));\r\n    }\r\n\r\n    readCurve (map: any, timeline: CurveTimeline, frameIndex: number) {\r\n        if (!map.curve) return;\r\n        if (map.curve === \"stepped\")\r\n            timeline.setStepped(frameIndex);\r\n        else if (Object.prototype.toString.call(map.curve) === '[object Array]') {\r\n            let curve: Array<number> = map.curve;\r\n            timeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\r\n        }\r\n    }\r\n\r\n    getValue (map: any, prop: string, defaultValue: any) {\r\n        return map[prop] !== undefined ? map[prop] : defaultValue;\r\n    }\r\n\r\n    static blendModeFromString (str: string): number {\r\n        if (str === 'multiply') return PIXI.BLEND_MODES.MULTIPLY;\r\n        if (str === 'additive') return PIXI.BLEND_MODES.ADD;\r\n        if (str === 'screen') return PIXI.BLEND_MODES.SCREEN;\r\n        if (str === 'normal') return PIXI.BLEND_MODES.NORMAL;\r\n        throw new Error(`Unknown blend mode: ${str}`);\r\n    }\r\n\r\n    static positionModeFromString (str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == \"fixed\") return PositionMode.Fixed;\r\n        if (str == \"percent\") return PositionMode.Percent;\r\n        throw new Error(`Unknown position mode: ${str}`);\r\n    }\r\n\r\n    static spacingModeFromString (str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == \"length\") return SpacingMode.Length;\r\n        if (str == \"fixed\") return SpacingMode.Fixed;\r\n        if (str == \"percent\") return SpacingMode.Percent;\r\n        throw new Error(`Unknown position mode: ${str}`);\r\n    }\r\n\r\n    static rotateModeFromString (str: string) {\r\n        str = str.toLowerCase();\r\n        if (str == \"tangent\") return RotateMode.Tangent;\r\n        if (str == \"chain\") return RotateMode.Chain;\r\n        if (str == \"chainscale\") return RotateMode.ChainScale;\r\n        throw new Error(`Unknown rotate mode: ${str}`);\r\n    }\r\n}\r\n\r\nclass LinkedMesh {\r\n    parent: string; skin: string;\r\n    slotIndex: number;\r\n    mesh: MeshAttachment;\r\n\r\n    constructor (mesh: MeshAttachment, skin: string, slotIndex: number, parent: string) {\r\n        this.mesh = mesh;\r\n        this.skin = skin;\r\n        this.slotIndex = slotIndex;\r\n        this.parent = parent;\r\n    }\r\n}\r\n","import {Attachment} from \"./attachments\";\r\nimport {Skeleton} from \"./Skeleton\";\r\nimport {Map} from \"./Utils\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class Skin {\r\n    name: string;\r\n    attachments = new Array<Map<Attachment>>();\r\n\r\n    constructor (name: string) {\r\n        if (name == null) throw new Error(\"name cannot be null.\");\r\n        this.name = name;\r\n    }\r\n\r\n    addAttachment (slotIndex: number, name: string, attachment: Attachment) {\r\n        if (attachment == null) throw new Error(\"attachment cannot be null.\");\r\n        let attachments = this.attachments;\r\n        if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\r\n        if (!attachments[slotIndex]) attachments[slotIndex] = { };\r\n        attachments[slotIndex][name] = attachment;\r\n    }\r\n\r\n    /** @return May be null. */\r\n    getAttachment (slotIndex: number, name: string): Attachment {\r\n        let dictionary = this.attachments[slotIndex];\r\n        return dictionary ? dictionary[name] : null;\r\n    }\r\n\r\n    /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\r\n    attachAll (skeleton: Skeleton, oldSkin: Skin) {\r\n        let slotIndex = 0;\r\n        for (let i = 0; i < skeleton.slots.length; i++) {\r\n            let slot = skeleton.slots[i];\r\n            let slotAttachment = slot.getAttachment();\r\n            if (slotAttachment && slotIndex < oldSkin.attachments.length) {\r\n                let dictionary = oldSkin.attachments[slotIndex];\r\n                for (let key in dictionary) {\r\n                    let skinAttachment:Attachment = dictionary[key];\r\n                    if (slotAttachment == skinAttachment) {\r\n                        let attachment = this.getAttachment(slotIndex, key);\r\n                        if (attachment != null) slot.setAttachment(attachment);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            slotIndex++;\r\n        }\r\n    }\r\n}\r\n","import {Attachment} from \"./attachments\";\r\nimport {SlotData} from \"./SlotData\";\r\nimport {Bone} from \"./Bone\";\r\nimport {Color} from \"./Utils\";\r\nimport {TextureRegion} from \"./Texture\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class Slot {\r\n    //this is for PIXI\r\n    currentMesh: any;\r\n    currentSprite: any;\r\n    meshes: any;\r\n    currentMeshName: String;\r\n    sprites: any;\r\n    currentSpriteName: String;\r\n    blendMode: number;\r\n    //assign hack region a bit later\r\n    tempRegion: TextureRegion;\r\n    tempAttachment: Attachment;\r\n\r\n    //canon\r\n    data: SlotData;\r\n    bone: Bone;\r\n    color: Color;\r\n    attachment: Attachment;\r\n    private attachmentTime: number;\r\n    attachmentVertices = new Array<number>();\r\n\r\n    constructor (data: SlotData, bone: Bone) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        if (bone == null) throw new Error(\"bone cannot be null.\");\r\n        this.data = data;\r\n        this.bone = bone;\r\n        this.color = new Color();\r\n        this.blendMode = data.blendMode;\r\n        this.setToSetupPose();\r\n    }\r\n\r\n    /** @return May be null. */\r\n    getAttachment (): Attachment {\r\n        return this.attachment;\r\n    }\r\n\r\n    /** Sets the attachment and if it changed, resets {@link #getAttachmentTime()} and clears {@link #getAttachmentVertices()}.\r\n     * @param attachment May be null. */\r\n    setAttachment (attachment: Attachment) {\r\n        if (this.attachment == attachment) return;\r\n        this.attachment = attachment;\r\n        this.attachmentTime = this.bone.skeleton.time;\r\n        this.attachmentVertices.length = 0;\r\n    }\r\n\r\n    setAttachmentTime (time: number) {\r\n        this.attachmentTime = this.bone.skeleton.time - time;\r\n    }\r\n\r\n    /** Returns the time since the attachment was set. */\r\n    getAttachmentTime (): number {\r\n        return this.bone.skeleton.time - this.attachmentTime;\r\n    }\r\n\r\n    setToSetupPose () {\r\n        this.color.setFromColor(this.data.color);\r\n        if (this.data.attachmentName == null)\r\n            this.attachment = null;\r\n        else {\r\n            this.attachment = null;\r\n            this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\r\n        }\r\n    }\r\n}\r\n","import {BoneData} from \"./BoneData\";\r\nimport {Color} from \"./Utils\";\r\nimport {BlendMode} from \"./BlendMode\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class SlotData {\r\n    index: number;\r\n    name: string;\r\n    boneData: BoneData;\r\n    color = new Color(1, 1, 1, 1);\r\n    attachmentName: string;\r\n    blendMode: number;\r\n\r\n    constructor (index: number, name: string, boneData: BoneData) {\r\n        if (index < 0) throw new Error(\"index must be >= 0.\");\r\n        if (name == null) throw new Error(\"name cannot be null.\");\r\n        if (boneData == null) throw new Error(\"boneData cannot be null.\");\r\n        this.index = index;\r\n        this.name = name;\r\n        this.boneData = boneData;\r\n    }\r\n}\r\n","export abstract class Texture {\r\n    protected _image: HTMLImageElement;\r\n\r\n    constructor (image: HTMLImageElement) {\r\n        this._image = image;\r\n    }\r\n\r\n    getImage (): HTMLImageElement {\r\n        return this._image;\r\n    }\r\n\r\n    abstract setFilters (minFilter: TextureFilter, magFilter: TextureFilter): void;\r\n    abstract setWraps (uWrap: TextureWrap, vWrap: TextureWrap): void;\r\n    abstract dispose (): void;\r\n\r\n\r\n    public static filterFromString (text: string): TextureFilter {\r\n        switch (text.toLowerCase()) {\r\n            case \"nearest\": return TextureFilter.Nearest;\r\n            case \"linear\": return TextureFilter.Linear;\r\n            case \"mipmap\": return TextureFilter.MipMap;\r\n            case \"mipmapnearestnearest\": return TextureFilter.MipMapNearestNearest;\r\n            case \"mipmaplinearnearest\": return TextureFilter.MipMapLinearNearest;\r\n            case \"mipmapnearestlinear\": return TextureFilter.MipMapNearestLinear;\r\n            case \"mipmaplinearlinear\": return TextureFilter.MipMapLinearLinear;\r\n            default: throw new Error(`Unknown texture filter ${text}`);\r\n        }\r\n    }\r\n\r\n    public static wrapFromString (text: string): TextureWrap {\r\n        switch (text.toLowerCase()) {\r\n            case \"mirroredtepeat\": return TextureWrap.MirroredRepeat;\r\n            case \"clamptoedge\": return TextureWrap.ClampToEdge;\r\n            case \"repeat\": return TextureWrap.Repeat;\r\n            default: throw new Error(`Unknown texture wrap ${text}`);\r\n        }\r\n    }\r\n}\r\n\r\nexport enum TextureFilter {\r\n    Nearest = 9728, // WebGLRenderingContext.NEAREST\r\n    Linear = 9729, // WebGLRenderingContext.LINEAR\r\n    MipMap = 9987, // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\r\n    MipMapNearestNearest = 9984, // WebGLRenderingContext.NEAREST_MIPMAP_NEAREST\r\n    MipMapLinearNearest = 9985, // WebGLRenderingContext.LINEAR_MIPMAP_NEAREST\r\n    MipMapNearestLinear = 9986, // WebGLRenderingContext.NEAREST_MIPMAP_LINEAR\r\n    MipMapLinearLinear = 9987 // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\r\n}\r\n\r\nexport enum TextureWrap {\r\n    MirroredRepeat = 33648, // WebGLRenderingContext.MIRRORED_REPEAT\r\n    ClampToEdge = 33071, // WebGLRenderingContext.CLAMP_TO_EDGE\r\n    Repeat = 10497 // WebGLRenderingContext.REPEAT\r\n}\r\n\r\nexport class TextureRegion {\r\n    texture: PIXI.Texture;\r\n\r\n    //thats for overrides\r\n    size: PIXI.Rectangle = null;\r\n\r\n    get width(): number {\r\n        const tex = this.texture;\r\n        if (PIXI.VERSION[0] == '3') {\r\n            return tex.crop.width;\r\n        }\r\n        if (tex.trim) {\r\n            return tex.trim.width;\r\n        }\r\n        return tex.orig.width;\r\n    }\r\n\r\n    get height(): number {\r\n        const tex = this.texture;\r\n        if (PIXI.VERSION[0] == '3') {\r\n            return tex.crop.height;\r\n        }\r\n        if (tex.trim) {\r\n            return tex.trim.height;\r\n        }\r\n        return tex.orig.height;\r\n    }\r\n\r\n    get u(): number {\r\n        return this.texture._uvs.x0;\r\n    }\r\n\r\n    get v(): number {\r\n        return this.texture._uvs.y0;\r\n    }\r\n\r\n    get u2(): number {\r\n        return this.texture._uvs.x2;\r\n    }\r\n\r\n    get v2(): number {\r\n        return this.texture._uvs.y2;\r\n    }\r\n\r\n    get offsetX(): number {\r\n        const tex = this.texture;\r\n        return tex.trim ? tex.trim.x : 0;\r\n    }\r\n\r\n    get offsetY(): number {\r\n        console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\r\n        return this.spineOffsetY;\r\n    }\r\n\r\n    get pixiOffsetY(): number {\r\n        const tex = this.texture;\r\n        return tex.trim ? tex.trim.y : 0;\r\n    }\r\n\r\n    get spineOffsetY(): number {\r\n        var tex = this.texture;\r\n        return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\r\n    }\r\n\r\n    get originalWidth(): number {\r\n        var tex = this.texture;\r\n        if (PIXI.VERSION[0] == '3') {\r\n            if (tex.trim) {\r\n                return tex.trim.width;\r\n            }\r\n            return tex.crop.width;\r\n        }\r\n        return tex.orig.width;\r\n    }\r\n\r\n    get originalHeight(): number {\r\n        const tex = this.texture;\r\n        if (PIXI.VERSION[0] == '3') {\r\n            if (tex.trim) {\r\n                return tex.trim.height;\r\n            }\r\n            return tex.crop.height;\r\n        }\r\n        return tex.orig.height;\r\n    }\r\n\r\n    get x(): number {\r\n        return this.texture.frame.x;\r\n    }\r\n\r\n    get y(): number {\r\n        return this.texture.frame.y;\r\n    }\r\n\r\n    get rotate(): boolean {\r\n        return this.texture.rotate !== 0;\r\n    }\r\n}\r\n","import {Disposable, Map} from \"./Utils\";\r\nimport {Texture, TextureWrap, TextureRegion, TextureFilter} from \"./Texture\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class TextureAtlas implements Disposable {\r\n    pages = new Array<TextureAtlasPage>();\r\n    regions = new Array<TextureAtlasRegion>();\r\n\r\n    constructor(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: PIXI.BaseTexture) => any) => any, callback: (obj: TextureAtlas) => any) {\r\n        if (atlasText) {\r\n            this.addSpineAtlas(atlasText, textureLoader, callback);\r\n        }\r\n    }\r\n\r\n    addTexture(name: string, texture: PIXI.Texture) {\r\n        let pages = this.pages;\r\n        let page: TextureAtlasPage = null;\r\n        for (var i=0;i<pages.length;i++) {\r\n            if (pages[i].baseTexture === texture.baseTexture) {\r\n                page = pages[i];\r\n                break;\r\n            }\r\n        }\r\n        if (page === null) {\r\n            page = new TextureAtlasPage();\r\n            page.name = 'texturePage';\r\n            var baseTexture = texture.baseTexture;\r\n            page.width = baseTexture.realWidth;\r\n            page.height = baseTexture.realHeight;\r\n            page.baseTexture = baseTexture;\r\n            //those fields are not relevant in Pixi\r\n            page.minFilter = page.magFilter = TextureFilter.Nearest;\r\n            page.uWrap = TextureWrap.ClampToEdge;\r\n            page.vWrap = TextureWrap.ClampToEdge;\r\n            pages.push(page);\r\n        }\r\n        var region = new TextureAtlasRegion();\r\n        region.name = name;\r\n        region.page = page;\r\n        region.texture = texture;\r\n        region.index = -1;\r\n        this.regions.push(region);\r\n        return region;\r\n    }\r\n\r\n    addTextureHash(textures: Map<PIXI.Texture>, stripExtension: boolean) {\r\n        for (var key in textures) {\r\n            if (textures.hasOwnProperty(key)) {\r\n                this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\r\n            }\r\n        }\r\n    }\r\n\r\n    public addSpineAtlas(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: PIXI.BaseTexture)  => any) => any, callback: (obj: TextureAtlas) => any) {\r\n        return this.load(atlasText, textureLoader, callback);\r\n    }\r\n\r\n    private load(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: PIXI.BaseTexture) => any) => any, callback: (obj: TextureAtlas) => any) {\r\n        if (textureLoader == null)\r\n            throw new Error(\"textureLoader cannot be null.\");\r\n\r\n        let reader = new TextureAtlasReader(atlasText);\r\n        let tuple = new Array<string>(4);\r\n        let page: TextureAtlasPage = null;\r\n\r\n        let iterateParser = () => {\r\n            while (true) {\r\n                let line = reader.readLine();\r\n                if (line == null) {\r\n                    return callback && callback(this);\r\n                }\r\n                line = line.trim();\r\n                if (line.length == 0)\r\n                    page = null;\r\n                else if (!page) {\r\n                    page = new TextureAtlasPage();\r\n                    page.name = line;\r\n\r\n                    if (reader.readTuple(tuple) == 2) { // size is only optional for an atlas packed with an old TexturePacker.\r\n                        page.width = parseInt(tuple[0]);\r\n                        page.height = parseInt(tuple[1]);\r\n                        reader.readTuple(tuple);\r\n                    }\r\n                    // page.format = Format[tuple[0]]; we don't need format in WebGL\r\n\r\n                    reader.readTuple(tuple);\r\n                    page.minFilter = Texture.filterFromString(tuple[0]);\r\n                    page.magFilter = Texture.filterFromString(tuple[1]);\r\n\r\n                    let direction = reader.readValue();\r\n                    page.uWrap = TextureWrap.ClampToEdge;\r\n                    page.vWrap = TextureWrap.ClampToEdge;\r\n                    if (direction == \"x\")\r\n                        page.uWrap = TextureWrap.Repeat;\r\n                    else if (direction == \"y\")\r\n                        page.vWrap = TextureWrap.Repeat;\r\n                    else if (direction == \"xy\")\r\n                        page.uWrap = page.vWrap = TextureWrap.Repeat;\r\n\r\n                    textureLoader(line, (texture: PIXI.BaseTexture) => {\r\n                        page.baseTexture = texture;\r\n                        if (!texture.hasLoaded) {\r\n                            texture.width = page.width;\r\n                            texture.height = page.height;\r\n                        }\r\n                        this.pages.push(page);\r\n                        page.setFilters();\r\n\r\n                        if (!page.width || !page.height) {\r\n                            page.width = texture.realWidth;\r\n                            page.height = texture.realHeight;\r\n                            if (!page.width || !page.height) {\r\n                                console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\r\n                            }\r\n                        }\r\n                        iterateParser();\r\n                    });\r\n                    this.pages.push(page);\r\n                    break;\r\n                } else {\r\n                    let region: TextureAtlasRegion = new TextureAtlasRegion();\r\n                    region.name = line;\r\n                    region.page = page;\r\n\r\n                    let rotate: number = reader.readValue() == \"true\" ? 6 : 0;\r\n\r\n                    reader.readTuple(tuple);\r\n                    let x = parseInt(tuple[0]);\r\n                    let y = parseInt(tuple[1]);\r\n\r\n                    reader.readTuple(tuple);\r\n                    let width = parseInt(tuple[0]);\r\n                    let height = parseInt(tuple[1]);\r\n\r\n                    let resolution = page.baseTexture.resolution;\r\n                    x /= resolution;\r\n                    y /= resolution;\r\n                    width /= resolution;\r\n                    height /= resolution;\r\n\r\n                    let frame = new PIXI.Rectangle(x, y, rotate ? height : width, rotate ? width : height);\r\n\r\n                    if (reader.readTuple(tuple) == 4) { // split is optional\r\n                        // region.splits = new Vector.<int>(parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3]));\r\n\r\n                        if (reader.readTuple(tuple) == 4) { // pad is optional, but only present with splits\r\n                            //region.pads = Vector.<int>(parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3]));\r\n\r\n                            reader.readTuple(tuple);\r\n                        }\r\n                    }\r\n\r\n                    let originalWidth = parseInt(tuple[0]) / resolution;\r\n                    let originalHeight = parseInt(tuple[1]) / resolution;\r\n                    reader.readTuple(tuple);\r\n                    let offsetX = parseInt(tuple[0]) / resolution;\r\n                    let offsetY = parseInt(tuple[1]) / resolution;\r\n\r\n                    let orig = new PIXI.Rectangle(0, 0, originalWidth, originalHeight);\r\n                    let trim = new PIXI.Rectangle(offsetX, originalHeight - height - offsetY, width, height);\r\n\r\n                    //TODO: pixiv3 uses different frame/crop/trim\r\n\r\n                    if (PIXI.VERSION[0] == '4') {\r\n                        // pixi v4.0.0\r\n                        region.texture = new PIXI.Texture(region.page.baseTexture, frame, orig, trim, rotate);\r\n                    } else {\r\n                        // pixi v3.0.11\r\n                        var frame2 = new PIXI.Rectangle(x, y, width, height);\r\n                        var crop = frame2.clone();\r\n                        trim.width = originalWidth;\r\n                        trim.height = originalHeight;\r\n                        region.texture = new PIXI.Texture(region.page.baseTexture, frame2, crop, trim, rotate);\r\n                    }\r\n\r\n                    region.index = parseInt(reader.readValue());\r\n                    region.texture._updateUvs();\r\n\r\n                    this.regions.push(region);\r\n                }\r\n            }\r\n        }\r\n\r\n        iterateParser();\r\n    }\r\n\r\n    findRegion(name: string): TextureAtlasRegion {\r\n        for (let i = 0; i < this.regions.length; i++) {\r\n            if (this.regions[i].name == name) {\r\n                return this.regions[i];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    dispose() {\r\n        for (let i = 0; i < this.pages.length; i++) {\r\n            this.pages[i].baseTexture.dispose();\r\n        }\r\n    }\r\n}\r\n\r\nclass TextureAtlasReader {\r\n    lines: Array<string>;\r\n    index: number = 0;\r\n\r\n    constructor(text: string) {\r\n        this.lines = text.split(/\\r\\n|\\r|\\n/);\r\n    }\r\n\r\n    readLine(): string {\r\n        if (this.index >= this.lines.length)\r\n            return null;\r\n        return this.lines[this.index++];\r\n    }\r\n\r\n    readValue(): string {\r\n        let line = this.readLine();\r\n        let colon = line.indexOf(\":\");\r\n        if (colon == -1)\r\n            throw new Error(\"Invalid line: \" + line);\r\n        return line.substring(colon + 1).trim();\r\n    }\r\n\r\n    readTuple(tuple: Array<string>): number {\r\n        let line = this.readLine();\r\n        let colon = line.indexOf(\":\");\r\n        if (colon == -1)\r\n            throw new Error(\"Invalid line: \" + line);\r\n        let i = 0, lastMatch = colon + 1;\r\n        for (; i < 3; i++) {\r\n            let comma = line.indexOf(\",\", lastMatch);\r\n            if (comma == -1) break;\r\n            tuple[i] = line.substr(lastMatch, comma - lastMatch).trim();\r\n            lastMatch = comma + 1;\r\n        }\r\n        tuple[i] = line.substring(lastMatch).trim();\r\n        return i + 1;\r\n    }\r\n}\r\n\r\nexport class TextureAtlasPage {\r\n    name: string;\r\n    minFilter: TextureFilter;\r\n    magFilter: TextureFilter;\r\n    uWrap: TextureWrap;\r\n    vWrap: TextureWrap;\r\n    baseTexture: PIXI.BaseTexture;\r\n    width: number;\r\n    height: number;\r\n\r\n    public setFilters() {\r\n        let tex = this.baseTexture;\r\n        let filter = this.minFilter;\r\n        if (filter == TextureFilter.Linear) {\r\n            tex.scaleMode = PIXI.SCALE_MODES.LINEAR;\r\n        } else if (this.minFilter == TextureFilter.Nearest) {\r\n            tex.scaleMode = PIXI.SCALE_MODES.NEAREST;\r\n        } else {\r\n            tex.mipmap = true;\r\n            if (filter == TextureFilter.MipMapNearestNearest) {\r\n                tex.scaleMode = PIXI.SCALE_MODES.NEAREST;\r\n            } else {\r\n                tex.scaleMode = PIXI.SCALE_MODES.LINEAR;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport class TextureAtlasRegion extends TextureRegion {\r\n    page: TextureAtlasPage;\r\n    name: string;\r\n    index: number;\r\n}\r\n","import {Skin} from \"./Skin\";\r\nimport {AttachmentLoader, BoundingBoxAttachment, MeshAttachment, PathAttachment, RegionAttachment} from \"./attachments\";\r\nimport {TextureAtlas} from \"./TextureAtlas\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class TextureAtlasAttachmentLoader implements AttachmentLoader {\r\n    atlas: TextureAtlas;\r\n\r\n    constructor (atlas: TextureAtlas) {\r\n        this.atlas = atlas;\r\n    }\r\n\r\n    /** @return May be null to not load an attachment. */\r\n    newRegionAttachment (skin: Skin, name: string, path: string): RegionAttachment {\r\n        let region = this.atlas.findRegion(path);\r\n        if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\");\r\n        let attachment = new RegionAttachment(name);\r\n        attachment.region = region;\r\n        return attachment;\r\n    }\r\n\r\n    /** @return May be null to not load an attachment. */\r\n    newMeshAttachment (skin: Skin, name: string, path: string) : MeshAttachment {\r\n        let region = this.atlas.findRegion(path);\r\n        if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\");\r\n        let attachment = new MeshAttachment(name);\r\n        attachment.region = region;\r\n        return attachment;\r\n    }\r\n\r\n    /** @return May be null to not load an attachment. */\r\n    newBoundingBoxAttachment (skin: Skin, name: string) : BoundingBoxAttachment {\r\n        return new BoundingBoxAttachment(name);\r\n    }\r\n\r\n    /** @return May be null to not load an attachment */\r\n    newPathAttachment (skin: Skin, name: string): PathAttachment {\r\n        return new PathAttachment(name);\r\n    }\r\n}\r\n","import {Updatable} from \"./Updatable\";\r\nimport {TransformConstraintData} from \"./TransformConstraintData\";\r\nimport {Bone} from \"./Bone\";\r\nimport {Vector2, MathUtils} from \"./Utils\";\r\nimport {Skeleton} from \"./Skeleton\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class TransformConstraint implements Updatable {\r\n    data: TransformConstraintData;\r\n    bones: Array<Bone>;\r\n    target: Bone;\r\n    rotateMix = 0; translateMix = 0; scaleMix = 0; shearMix = 0;\r\n    temp = new Vector2();\r\n\r\n    constructor (data: TransformConstraintData, skeleton: Skeleton) {\r\n        if (data == null) throw new Error(\"data cannot be null.\");\r\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n        this.data = data;\r\n        this.rotateMix = data.rotateMix;\r\n        this.translateMix = data.translateMix;\r\n        this.scaleMix = data.scaleMix;\r\n        this.shearMix = data.shearMix;\r\n        this.bones = new Array<Bone>();\r\n        for (let i = 0; i < data.bones.length; i++)\r\n            this.bones.push(skeleton.findBone(data.bones[i].name));\r\n        this.target = skeleton.findBone(data.target.name);\r\n    }\r\n\r\n    apply () {\r\n        this.update();\r\n    }\r\n\r\n    update () {\r\n        let rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n        let target = this.target;\r\n        let tm = target.matrix;\r\n        let ta = tm.a, tb = tm.c, tc = tm.b, td = tm.d;\r\n        let bones = this.bones;\r\n        for (let i = 0, n = bones.length; i < n; i++) {\r\n            let bone = bones[i];\r\n            let m = bone.matrix;\r\n\r\n            if (rotateMix > 0) {\r\n                let a = m.a, b = m.c, c = m.b, d = m.d;\r\n                let r = Math.atan2(tc, ta) - Math.atan2(c, a) + this.data.offsetRotation * MathUtils.degRad;\r\n                if (r > MathUtils.PI)\r\n                    r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI)\r\n                    r += MathUtils.PI2;\r\n                r *= rotateMix;\r\n                let cos = Math.cos(r), sin = Math.sin(r);\r\n                m.a = cos * a - sin * c;\r\n                m.c = cos * b - sin * d;\r\n                m.b = sin * a + cos * c;\r\n                m.d = sin * b + cos * d;\r\n            }\r\n\r\n            if (translateMix > 0) {\r\n                let temp = this.temp;\r\n                target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n                m.tx += (temp.x - bone.worldX) * translateMix;\r\n                m.ty += (temp.y - bone.worldY) * translateMix;\r\n            }\r\n\r\n            if (scaleMix > 0) {\r\n                let bs = Math.sqrt(m.a * m.a + m.b * m.b);\r\n                let ts = Math.sqrt(ta * ta + tc * tc);\r\n                let s = bs > 0.00001 ? (bs + (ts - bs + this.data.offsetScaleX) * scaleMix) / bs : 0;\r\n                m.a *= s;\r\n                m.b *= s;\r\n                bs = Math.sqrt(m.c * m.c + m.d * m.d);\r\n                ts = Math.sqrt(tb * tb + td * td);\r\n                s = bs > 0.00001 ? (bs + (ts - bs + this.data.offsetScaleY) * scaleMix) / bs : 0;\r\n                m.c *= s;\r\n                m.d *= s;\r\n            }\r\n\r\n            if (shearMix > 0) {\r\n                let b = m.c, d = m.d;\r\n                let by = Math.atan2(d, b);\r\n                let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(m.b, m.a));\r\n                if (r > MathUtils.PI)\r\n                    r -= MathUtils.PI2;\r\n                else if (r < -MathUtils.PI)\r\n                    r += MathUtils.PI2;\r\n                r = by + (r + this.data.offsetShearY * MathUtils.degRad) * shearMix;\r\n                let s = Math.sqrt(b * b + d * d);\r\n                m.c = Math.cos(r) * s;\r\n                m.d = Math.sin(r) * s;\r\n            }\r\n        }\r\n    }\r\n}\r\n","import {BoneData} from \"./BoneData\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class TransformConstraintData {\r\n    name: string;\r\n    bones = new Array<BoneData>();\r\n    target: BoneData;\r\n    rotateMix = 0; translateMix = 0; scaleMix = 0; shearMix = 0;\r\n    offsetRotation = 0; offsetX = 0; offsetY = 0; offsetScaleX = 0; offsetScaleY = 0; offsetShearY = 0;\r\n\r\n    constructor (name: string) {\r\n        if (name == null) throw new Error(\"name cannot be null.\");\r\n        this.name = name;\r\n    }\r\n}\r\n","import {Skeleton} from \"./Skeleton\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport interface Map<T> {\r\n    [key: string]: T;\r\n}\r\n\r\nexport interface Disposable {\r\n    dispose (): void;\r\n}\r\n\r\nexport class Color {\r\n    public static WHITE = new Color(1, 1, 1, 1);\r\n    public static RED = new Color(1, 0, 0, 1);\r\n    public static GREEN = new Color(0, 1, 0, 1);\r\n    public static BLUE = new Color(0, 0, 1, 1);\r\n    public static MAGENTA = new Color(1, 0, 1, 1);\r\n\r\n    constructor (public r: number = 0, public g: number = 0, public b: number = 0, public a: number = 0) {\r\n    }\r\n\r\n    set (r: number, g: number, b: number, a: number) {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n        this.a = a;\r\n        this.clamp();\r\n        return this;\r\n    }\r\n\r\n    setFromColor (c: Color) {\r\n        this.r = c.r;\r\n        this.g = c.g;\r\n        this.b = c.b;\r\n        this.a = c.a;\r\n        return this;\r\n    }\r\n\r\n    setFromString (hex: string) {\r\n        hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\r\n        this.r = parseInt(hex.substr(0, 2), 16) / 255.0;\r\n        this.g = parseInt(hex.substr(2, 2), 16) / 255.0;\r\n        this.b = parseInt(hex.substr(4, 2), 16) / 255.0;\r\n        this.a = (hex.length != 8 ? 255 : parseInt(hex.substr(6, 2), 16)) / 255.0;\r\n        return this;\r\n    }\r\n\r\n    add (r: number, g: number, b: number, a: number) {\r\n        this.r += r;\r\n        this.g += g;\r\n        this.b += b;\r\n        this.a += a;\r\n        this.clamp();\r\n        return this;\r\n    }\r\n\r\n    clamp () {\r\n        if (this.r < 0) this.r = 0;\r\n        else if (this.r > 1) this.r = 1;\r\n\r\n        if (this.g < 0) this.g = 0;\r\n        else if (this.g > 1) this.g = 1;\r\n\r\n        if (this.b < 0) this.b = 0;\r\n        else if (this.b > 1) this.b = 1;\r\n\r\n        if (this.a < 0) this.a = 0;\r\n        else if (this.a > 1) this.a = 1;\r\n        return this;\r\n    }\r\n}\r\n\r\nexport class MathUtils {\r\n    static PI = 3.1415927;\r\n    static PI2 = MathUtils.PI * 2;\r\n    static radiansToDegrees = 180 / MathUtils.PI;\r\n    static radDeg = MathUtils.radiansToDegrees;\r\n    static degreesToRadians = MathUtils.PI / 180;\r\n    static degRad = MathUtils.degreesToRadians;\r\n\r\n    static clamp (value: number, min: number, max: number) {\r\n        if (value < min) return min;\r\n        if (value > max) return max;\r\n        return value;\r\n    }\r\n\r\n    static cosDeg (degrees: number) {\r\n        return Math.cos(degrees * MathUtils.degRad);\r\n    }\r\n\r\n    static sinDeg (degrees: number) {\r\n        return Math.sin(degrees * MathUtils.degRad);\r\n    }\r\n\r\n    static signum (value: number): number {\r\n        return value >= 0 ? 1 : -1;\r\n    }\r\n\r\n    static toInt (x: number) {\r\n        return x > 0 ? Math.floor(x) : Math.ceil(x);\r\n    }\r\n\r\n    static cbrt (x: number) {\r\n        var y = Math.pow(Math.abs(x), 1/3);\r\n        return x < 0 ? -y : y;\r\n    }\r\n}\r\n\r\nexport class Utils {\r\n    static SUPPORTS_TYPED_ARRAYS = typeof(Float32Array) !== \"undefined\";\r\n\r\n    static arrayCopy<T> (source: ArrayLike<T>, sourceStart: number, dest: ArrayLike<T>, destStart: number, numElements: number) {\r\n        for (let i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\r\n            dest[j] = source[i];\r\n        }\r\n    }\r\n\r\n    static setArraySize<T> (array: Array<T>, size: number, value: any = 0): Array<T> {\r\n        let oldSize = array.length;\r\n        if (oldSize == size) return array;\r\n        array.length = size;\r\n        if (oldSize < size) {\r\n            for (let i = oldSize; i < size; i++) array[i] = value;\r\n        }\r\n        return array;\r\n    }\r\n\r\n    static newArray<T> (size: number, defaultValue: T): Array<T> {\r\n        let array = new Array<T>(size);\r\n        for (let i = 0; i < size; i++) array[i] = defaultValue;\r\n        return array;\r\n    }\r\n\r\n    static newFloatArray (size: number): ArrayLike<number> {\r\n        if (Utils.SUPPORTS_TYPED_ARRAYS) {\r\n            return new Float32Array(size)\r\n        } else {\r\n             let array = new Array<number>(size);\r\n             for (let i = 0; i < array.length; i++) array[i] = 0;\r\n             return array;\r\n        }\r\n    }\r\n\r\n    static toFloatArray (array: Array<number>) {\r\n        return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\r\n    }\r\n}\r\n\r\nexport class DebugUtils {\r\n    static logBones(skeleton: Skeleton) {\r\n        for (let i = 0; i < skeleton.bones.length; i++) {\r\n            let bone = skeleton.bones[i];\r\n            let m = bone.matrix;\r\n            console.log(bone.data.name + \", \" + m.a + \", \" + m.b + \", \" + m.c + \", \" + m.d + \", \" + m.tx + \", \" + m.ty);\r\n        }\r\n    }\r\n}\r\n\r\nexport class Pool<T> {\r\n    private items = new Array<T>();\r\n    private instantiator: () => T;\r\n\r\n    constructor (instantiator: () => T) {\r\n        this.instantiator = instantiator;\r\n    }\r\n\r\n    obtain () {\r\n        return this.items.length > 0 ? this.items.pop() : this.instantiator();\r\n    }\r\n\r\n    free (item: T) {\r\n        this.items.push(item);\r\n    }\r\n\r\n    freeAll (items: ArrayLike<T>) {\r\n        for (let i = 0; i < items.length; i++) this.items[i] = items[i];\r\n    }\r\n\r\n    clear () {\r\n        this.items.length = 0;\r\n    }\r\n}\r\n\r\nexport class Vector2 {\r\n    constructor (public x = 0, public y = 0) {\r\n    }\r\n\r\n    set (x: number, y: number): Vector2 {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    length () {\r\n        let x = this.x;\r\n        let y = this.y;\r\n        return Math.sqrt(x * x + y * y);\r\n    }\r\n\r\n    normalize () {\r\n        let len = this.length();\r\n        if (len != 0) {\r\n            this.x /= len;\r\n            this.y /= len;\r\n        }\r\n        return this;\r\n    }\r\n}\r\n\r\nexport class TimeKeeper {\r\n    maxDelta = 0.064;\r\n    framesPerSecond = 0;\r\n    delta = 0;\r\n    totalTime = 0;\r\n\r\n    private lastTime = Date.now() / 1000;\r\n    private frameCount = 0;\r\n    private frameTime = 0;\r\n\r\n    update () {\r\n        var now = Date.now() / 1000;\r\n        this.delta = now - this.lastTime;\r\n        this.frameTime += this.delta;\r\n        this.totalTime += this.delta;\r\n        if (this.delta > this.maxDelta) this.delta = this.maxDelta;\r\n        this.lastTime = now;\r\n\r\n        this.frameCount++;\r\n        if (this.frameTime > 1) {\r\n            this.framesPerSecond = this.frameCount / this.frameTime;\r\n            this.frameTime = 0;\r\n            this.frameCount = 0;\r\n        }\r\n    }\r\n}\r\n","import {Slot} from \"../Slot\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport abstract class Attachment {\r\n    name: string;\r\n\r\n    constructor (name: string) {\r\n        if (name == null) throw new Error(\"name cannot be null.\");\r\n        this.name = name;\r\n    }\r\n}\r\n\r\nexport abstract class VertexAttachment extends Attachment {\r\n    bones: Array<number>;\r\n    vertices: ArrayLike<number>;\r\n    worldVerticesLength = 0;\r\n\r\n    constructor (name: string) {\r\n        super(name);\r\n    }\r\n\r\n    computeWorldVertices (slot: Slot, worldVertices: ArrayLike<number>) {\r\n        this.computeWorldVerticesWith(slot, 0, this.worldVerticesLength, worldVertices, 0);\r\n    }\r\n\r\n    /** Transforms local vertices to world coordinates.\r\n     * @param start The index of the first local vertex value to transform. Each vertex has 2 values, x and y.\r\n     * @param count The number of world vertex values to output. Must be <= {@link #getWorldVerticesLength()} - start.\r\n     * @param worldVertices The output world vertices. Must have a length >= offset + count.\r\n     * @param offset The worldVertices index to begin writing values. */\r\n    computeWorldVerticesWith (slot: Slot, start: number, count: number, worldVertices: ArrayLike<number>, offset: number) {\r\n        count += offset;\r\n        let skeleton = slot.bone.skeleton;\r\n        let x = skeleton.x, y = skeleton.y;\r\n        let deformArray = slot.attachmentVertices;\r\n        let vertices = this.vertices;\r\n        let bones = this.bones;\r\n        if (bones == null) {\r\n            if (deformArray.length > 0) vertices = deformArray;\r\n            let bone = slot.bone;\r\n            let m = bone.matrix;\r\n            x += m.tx;\r\n            y += m.ty;\r\n            let a = m.a, b = m.c, c = m.b, d = m.d;\r\n            for (let v = start, w = offset; w < count; v += 2, w += 2) {\r\n                let vx = vertices[v], vy = vertices[v + 1];\r\n                worldVertices[w] = vx * a + vy * b + x;\r\n                worldVertices[w + 1] = vx * c + vy * d + y;\r\n            }\r\n            return;\r\n        }\r\n        let v = 0, skip = 0;\r\n        for (let i = 0; i < start; i += 2) {\r\n            let n = bones[v];\r\n            v += n + 1;\r\n            skip += n;\r\n        }\r\n        let skeletonBones = skeleton.bones;\r\n        if (deformArray.length == 0) {\r\n            for (let w = offset, b = skip * 3; w < count; w += 2) {\r\n                let wx = x, wy = y;\r\n                let n = bones[v++];\r\n                n += v;\r\n                for (; v < n; v++, b += 3) {\r\n                    let bone = skeletonBones[bones[v]];\r\n                    let m = bone.matrix;\r\n                    let vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];\r\n                    wx += (vx * m.a + vy * m.c + m.tx) * weight;\r\n                    wy += (vx * m.b + vy * m.d + m.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx;\r\n                worldVertices[w + 1] = wy;\r\n            }\r\n        } else {\r\n            let deform = deformArray;\r\n            for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += 2) {\r\n                let wx = x, wy = y;\r\n                let n = bones[v++];\r\n                n += v;\r\n                for (; v < n; v++, b += 3, f += 2) {\r\n                    let bone = skeletonBones[bones[v]];\r\n                    let m = bone.matrix;\r\n                    let vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];\r\n                    wx += (vx * m.a + vy * m.c + m.tx) * weight;\r\n                    wy += (vx * m.b + vy * m.d + m.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx;\r\n                worldVertices[w + 1] = wy;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Returns true if a deform originally applied to the specified attachment should be applied to this attachment. */\r\n    applyDeform (sourceAttachment: VertexAttachment) {\r\n        return this == sourceAttachment;\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport enum AttachmentType {\r\n    Region, BoundingBox, Mesh, LinkedMesh, Path\r\n}\r\n","import {VertexAttachment} from \"./Attachment\";\r\nimport {Color} from \"../Utils\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class BoundingBoxAttachment extends VertexAttachment {\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n}\r\n","import {VertexAttachment} from \"./Attachment\";\r\nimport {TextureRegion} from \"../Texture\";\r\nimport {Color, Utils} from \"../Utils\";\r\nimport {Slot} from \"../Slot\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class MeshAttachment extends VertexAttachment {\r\n    region: TextureRegion;\r\n    path: string;\r\n    regionUVs: ArrayLike<number>;\r\n    triangles: Array<number>;\r\n    color = new Color(1, 1, 1, 1);\r\n    hullLength: number;\r\n    private parentMesh: MeshAttachment;\r\n    inheritDeform = false;\r\n    tempColor = new Color(0, 0, 0, 0);\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    updateWorldVertices(slot: Slot, premultipliedAlpha: boolean): ArrayLike<number> {\r\n        return [];\r\n        //nothing\r\n    }\r\n\r\n    updateUVs(region: TextureRegion, uvs: ArrayLike<number>): ArrayLike<number> {\r\n        let regionUVs = this.regionUVs;\r\n        let n = regionUVs.length;\r\n        if (!uvs || uvs.length != n) {\r\n            uvs = Utils.newFloatArray(n);\r\n        }\r\n\r\n        if (region == null) {\r\n            return;\r\n        }\r\n\r\n        let texture = region.texture;\r\n        let r = texture._uvs;\r\n        let w1 = region.width, h1 = region.height, w2 = region.originalWidth, h2 = region.originalHeight;\r\n        let x = region.offsetX, y = region.pixiOffsetY;\r\n\r\n        for (let i = 0; i < n; i += 2) {\r\n            let u = this.regionUVs[i], v = this.regionUVs[i + 1];\r\n            u = (u * w2 - x) / w1;\r\n            v = (v * h2 - y) / h1;\r\n            uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1 - v) + (r.x3 * (1 - u) + r.x2 * u) * v;\r\n            uvs[i + 1] = (r.y0 * (1 - u) + r.y1 * u) * (1 - v) + (r.y3 * (1 - u) + r.y2 * u) * v;\r\n        }\r\n\r\n        return uvs;\r\n    }\r\n\r\n    applyDeform(sourceAttachment: VertexAttachment): boolean {\r\n        return this == sourceAttachment || (this.inheritDeform && this.parentMesh == sourceAttachment);\r\n    }\r\n\r\n    getParentMesh() {\r\n        return this.parentMesh;\r\n    }\r\n\r\n    /** @param parentMesh May be null. */\r\n    setParentMesh(parentMesh: MeshAttachment) {\r\n        this.parentMesh = parentMesh;\r\n        if (parentMesh != null) {\r\n            this.bones = parentMesh.bones;\r\n            this.vertices = parentMesh.vertices;\r\n            this.regionUVs = parentMesh.regionUVs;\r\n            this.triangles = parentMesh.triangles;\r\n            this.hullLength = parentMesh.hullLength;\r\n        }\r\n    }\r\n}\r\n","import {VertexAttachment} from \"./Attachment\";\r\nimport {Color} from \"../Utils\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class PathAttachment extends VertexAttachment {\r\n    lengths: Array<number>;\r\n    closed = false; constantSpeed = false;\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    constructor (name: string) {\r\n        super(name);\r\n    }\r\n}\r\n","import {Attachment} from \"./Attachment\";\r\nimport {Color, Utils} from \"../Utils\";\r\nimport {TextureRegion} from \"../Texture\";\r\nimport {Slot} from \"../Slot\";\r\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nexport class RegionAttachment extends Attachment {\r\n    x = 0; y = 0; scaleX = 1; scaleY = 1; rotation = 0; width = 0; height = 0;\r\n    color = new Color(1, 1, 1, 1);\r\n\r\n    path: string;\r\n    region: TextureRegion;\r\n\r\n    constructor (name:string) {\r\n        super(name);\r\n    }\r\n\r\n    updateWorldVertices(slot: Slot, premultipliedAlpha: boolean): ArrayLike<number> {\r\n        return [];\r\n        //nothing\r\n    }\r\n}\r\n","export {Attachment, VertexAttachment} from \"./Attachment\";\r\nexport {AttachmentLoader} from \"./AttachmentLoader\";\r\nexport {AttachmentType} from \"./AttachmentType\";\r\nexport {BoundingBoxAttachment} from \"./BoundingBoxAttachment\";\r\nexport {MeshAttachment} from \"./MeshAttachment\";\r\nexport {PathAttachment} from \"./PathAttachment\";\r\nexport {RegionAttachment} from \"./RegionAttachment\";\r\n","export * from \"./attachments\";\r\n\r\nexport {\r\n    Timeline, ColorTimeline, AttachmentTimeline, RotateTimeline, TranslateTimeline,\r\n    ScaleTimeline, ShearTimeline, IkConstraintTimeline, TransformConstraintTimeline, PathConstraintPositionTimeline,\r\n    PathConstraintSpacingTimeline, PathConstraintMixTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline,\r\n    Animation, CurveTimeline\r\n} from \"./Animation\";\r\nexport {AnimationState} from \"./AnimationState\";\r\nexport {AnimationStateData} from \"./AnimationStateData\";\r\nexport {BlendMode} from \"./BlendMode\";\r\nexport {Bone} from \"./Bone\";\r\nexport {BoneData} from \"./BoneData\";\r\nexport {Event} from \"./Event\";\r\nexport {EventData} from \"./EventData\";\r\nexport {IkConstraint} from \"./IkConstraint\";\r\nexport {IkConstraintData} from \"./IkConstraintData\";\r\nexport {PathConstraint} from \"./PathConstraint\";\r\nexport {PathConstraintData, SpacingMode, RotateMode, PositionMode} from \"./PathConstraintData\";\r\nexport {Skeleton} from \"./Skeleton\";\r\nexport {SkeletonBounds} from \"./SkeletonBounds\";\r\nexport {SkeletonData} from \"./SkeletonData\";\r\nexport {SkeletonJson} from \"./SkeletonJson\";\r\nexport {Skin} from \"./Skin\";\r\nexport {Slot} from \"./Slot\";\r\nexport {SlotData} from \"./SlotData\";\r\nexport {Texture, TextureWrap, TextureRegion, TextureFilter} from \"./Texture\";\r\nexport {TextureAtlas, TextureAtlasRegion} from \"./TextureAtlas\";\r\nexport {TextureAtlasAttachmentLoader} from \"./TextureAtlasAttachmentLoader\";\r\nexport {TransformConstraint} from \"./TransformConstraint\";\r\nexport {TransformConstraintData} from \"./TransformConstraintData\";\r\nexport {Updatable} from \"./Updatable\";\r\nexport {Disposable, Map, Utils, Pool, MathUtils, Color, Vector2} from \"./Utils\";\r\n","import * as spine from \"./core\";\r\n\r\nexport function atlasParser() {\r\n    return function (resource: PIXI.loaders.Resource, next: () => any) {\r\n        // skip if no data, its not json, or it isn't atlas data\r\n        if (!resource.data || !resource.isJson || !resource.data.bones) {\r\n            return next();\r\n        }\r\n\r\n        var metadataAtlas = resource.metadata ? resource.metadata.spineAtlas: null;\r\n        if (metadataAtlas === false) {\r\n            return next();\r\n        }\r\n        if (metadataAtlas && metadataAtlas.pages) {\r\n            //its an atlas!\r\n            var spineJsonParser = new spine.SkeletonJson(new spine.TextureAtlasAttachmentLoader(metadataAtlas));\r\n            var skeletonData = spineJsonParser.readSkeletonData(resource.data);\r\n\r\n            resource.spineData = skeletonData;\r\n            resource.spineAtlas = metadataAtlas;\r\n\r\n            return next();\r\n        }\r\n\r\n        var metadataAtlasSuffix = '.atlas';\r\n        if (resource.metadata && resource.metadata.spineAtlasSuffix) {\r\n            metadataAtlasSuffix = resource.metadata.spineAtlasSuffix;\r\n        }\r\n\r\n        /**\r\n         * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files\r\n         * that correspond to the spine file are in the same base URL and that the .json and .atlas files\r\n         * have the same name\r\n         */\r\n        var atlasPath = resource.url.substr(0, resource.url.lastIndexOf('.')) + metadataAtlasSuffix;\r\n        //remove the baseUrl\r\n        atlasPath = atlasPath.replace(this.baseUrl, '');\r\n\r\n        var atlasOptions = {\r\n            crossOrigin: resource.crossOrigin,\r\n            xhrType: PIXI.loaders.Resource.XHR_RESPONSE_TYPE.TEXT,\r\n            metadata: resource.metadata ? resource.metadata.spineMetadata : null\r\n        };\r\n        var imageOptions = {\r\n            crossOrigin: resource.crossOrigin,\r\n            metadata: resource.metadata ? resource.metadata.imageMetadata: null\r\n        };\r\n        var baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\r\n        //remove the baseUrl\r\n        baseUrl = baseUrl.replace(this.baseUrl, '');\r\n\r\n        var adapter = imageLoaderAdapter(this, resource.name + '_atlas_page_', baseUrl, imageOptions);\r\n\r\n        this.add(resource.name + '_atlas', atlasPath, atlasOptions, function () {\r\n            new spine.TextureAtlas(this.xhr.responseText, adapter, function(spineAtlas) {\r\n                var spineJsonParser = new spine.SkeletonJson(new spine.TextureAtlasAttachmentLoader(spineAtlas));\r\n                var skeletonData = spineJsonParser.readSkeletonData(resource.data);\r\n\r\n                resource.spineData = skeletonData;\r\n                resource.spineAtlas = spineAtlas;\r\n\r\n                next();\r\n            });\r\n        });\r\n    };\r\n}\r\n\r\nexport function imageLoaderAdapter(loader: any, namePrefix: any, baseUrl: any, imageOptions: any) {\r\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\r\n    {\r\n        baseUrl += '/';\r\n    }\r\n    return function(line: String, callback: (baseTexture: PIXI.BaseTexture) => any) {\r\n        var name = namePrefix + line;\r\n        var url = baseUrl + line;\r\n        loader.add(name, url, imageOptions, (resource: PIXI.loaders.Resource) => {\r\n            callback(resource.texture.baseTexture);\r\n        });\r\n    }\r\n}\r\n\r\nexport function syncImageLoaderAdapter (baseUrl: any, crossOrigin: any) {\r\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\r\n    {\r\n        baseUrl += '/';\r\n    }\r\n    return function(line: any, callback: any) {\r\n        callback(PIXI.BaseTexture.fromImage(line, crossOrigin));\r\n    }\r\n}\r\n\r\nPIXI.loaders.Loader.addPixiMiddleware(atlasParser);\r\nPIXI.loader.use(atlasParser());\r\n","import * as core from \"./core\";\r\nimport * as loaders from \"./loaders\";\r\n\r\nexport {core, loaders}\r\nexport {Spine, SpineMesh, SpineSprite} from \"./Spine\";\r\n"],"sourceRoot":"/source/"}